[OpenGL 3D 2022 第05回]

# 衝突！ ゲームオブジェクト

## 習得目標

* 
* 
* 

## 1. ゲームオブジェクトの作成

### 1.1 コンポーネントクラスを作る

ゲームキャラクターを制御するために、`GameObject`(ゲーム・オブジェクト)クラスを作成します。ゲームオブジェクトは以下の機能を持ちます。

>* 表示するスプライトデータの管理。
>* 更新、衝突等のイベント管理。
>* 衝突判定データの管理と衝突判定。

このうち、「スプライトデータ」はすでに作成済みなので、残りの2つを作成します。まずは「イベント管理」から作っていきましょう。

最初に、イベント処理の基底クラスとなる`Component`(コンポーネント)クラスを作成します。

プロジェクトの`Src`フォルダに`Component.h`というファイルを追加してください。追加したファイルを開き、次のプログラムを追加してください。

```diff
+/**
+* @file Component.h
+*/
+#ifndef COMOPNENT_H_INCLUDED
+#define COMOPNENT_H_INCLUDED
+#include <string>
+#include <vector>
+#include <memory>
+
+// 先行宣言
+class GameObject;
+class Component;
+
+// コンポーネントのポインタ
+using ComponentPtr = std::shared_ptr<Component>;
+
+// コンポーネントポインタの配列
+using ComponentList = std::vector<ComponentPtr>;
+
+/**
+* コンポーネントの基底クラス
+*/
+class Component
+{
+public:
+  Component() = default;
+  virtual ~Component() = default;
+
+  // 最初のUpdateの直前で呼び出される
+  virtual void Start(GameObject& gameObject) {}
+
+  // 毎フレーム1回呼び出される
+  virtual void Update(GameObject& gameObject, float deltaTime) {}
+
+  // 衝突が起きたときに呼び出される
+  virtual void OnCollide(GameObject& gameObject, GameObject& other) {}
+
+  // ゲームオブジェクトが削除される瞬間に呼び出される
+  virtual void OnDestroy(GameObject& gameObject) {}
+
+  std::string name; // コンポーネント名
+};
+
+#endif // COMOPNENT_H_INCLUDED
```

`Component`クラスは4つのイベントに対応する仮想関数を持っています。`Component`クラス自体はこれらのイベントに対して何も行いません。

特定の処理をさせたい場合、`Component`の派生クラスで実装します。そして、派生クラスをゲームオブジェクトに追加します。

### 1.2 ゲームオブジェクトクラスを作る

これで、ゲームオブジェクトを構成する3つの主要なクラスが完成しました。さっそく、ゲームオブジェクトを作っていきましょう。

プロジェクトの`Src`フォルダに`GameObject.h`という名前のヘッダファイルを追加してください。追加したファイルを開き、次のプログラムを追加してください。

```diff
+/**
+* @file GameObject.h
+*/
+#ifndef GAMEOBJECT_H_INCLUDED
+#define GAMEOBJECT_H_INCLUDED
+#include "Sprite.h"
+#include "Rect.h"
+#include "Component.h"
+#include <string>
+#include <vector>
+#include <memory>
+
+// 先行宣言
+class Engine;
+class GameObject;
+
+// ゲームオブジェクトのポインタ
+using GameObjectPtr = std::shared_ptr<GameObject>;
+
+// ゲームオブジェクトポインタの配列
+using GameObjectList = std::vector<GameObjectPtr>;
+
+/**
+* ゲーム内に登場するさまざまなオブジェクトを表す基本クラス
+*/
+class GameObject
+{
+public:
+  GameObject() = default;
+  virtual ~GameObject();
+
+  // イベントの操作
+  virtual void Start();
+  virtual void Update(float deltaTime);
+  virtual void OnCollide(GameObject& object);
+  bool IsStarted() const { return isStarted; }
+
+  // スプライトの操作
+  void AddSprite(const Texcoord& tc,
+    float x = 0, float y = 0, float scale = 1, float rotation = 0);
+  const SpriteList& GetSprite() const { return spriteList; }
+
+  // コンポーネントの操作
+  template<typename T>
+  T* AddComponent() {
+    componentList.push_back(std::make_shared<T>());
+    return static_cast<T*>(componentList.back().get());
+  }
+
+  Engine* engine = nullptr;    // エンジンのアドレス
+  std::string name;            // オブジェクト名
+  float x = 0;                 // X座標
+  float y = 0;                 // Y座標
+  int priority = 0;            // 表示優先順位
+  float health = 0;            // 耐久値
+  bool isDead = false;         // 死亡フラグ
+  ComponentList componentList; // コンポーネント配列
+  SpriteList spriteList;       // スプライト配列
+
+private:
+  // クラス外で勝手に操作されると困る変数
+  bool isStarted = false;     // Start実行済みフラグ
+};
+
+#endif // GAMEOBJECT_H_INCLUDED
```

プログラムを簡単にするため、`GameObject`クラスには、よく使われるパラメータをメンバ変数として組み込んでいます。一部のゲームエンジンでは、これらはコンポーネントとして作成されます。

しかし、コンポーネントとして作成する場合、そのコンポーネントが必要となるたびに、所定のコンポーネントを持っていることをチェックし、コンポーネントを取得するプログラムを書かなくてはなりません。

メンバ変数にすることで、コンポーネントのチェックや取得のためのプログラムをなくすことができます。その代わり、耐久値などを必要としないゲームオブジェクトにも、耐久値が付与されることになります。

>これは「継承」を使えば解決できる問題ですが、今回は継承構造を複雑にすることを避けるために、基底クラスに組み込むことを選びました。

`AddComponent`(アド・コンポーネント)はコンポーネントを追加する「関数テンプレート」です。テンプレート引数には、`Component`クラスの派生クラスを指定します。

関数テンプレートを使うと「異なる型に対して同じ処理をする」関数を書くことができます。関数テンプレートを使うと、型が異なる以外は同じ処理をする関数を何度も書かなくて済みます。

ただし、関数テンプレートには「定義をヘッダファイルに書かなくてはならない」という制限があります。関数によっては、これが問題でテンプレートにできないかもしれません。

### 1.3 ゲームオブジェクトのメンバ関数を定義する

次に`GameObject`クラスのメンバ関数を定義します。プロジェクトの`Src`フォルダに`GameObject.cpp`という名前のCPPファイルを追加してください。

追加したファイルを開き、次のプログラムを追加してください。

```diff
+/**
+* @file GameObject.cpp
+*/
+#include "GameObject.h"
+#include <algorithm>
+
+/**
+* デストラクタ
+*/
+GameObject::~GameObject()
+{
+  for (auto& e : componentList) {
+    e->OnDestroy(*this);
+  }
+}
+
+/**
+* スタートイベント
+*/
+void GameObject::Start()
+{
+  if (isStarted) {
+    return;
+  } 
+  for (auto& e : componentList) {
+    e->Start(*this);
+  }
+  isStarted = true;
+}
+
+/**
+* 更新イベント
+*/
+void GameObject::Update(float deltaTime)
+{
+  for (auto& e : componentList) {
+    e->Update(*this, deltaTime);
+  }
+}
+
+/**
+* コリジョンイベント
+*/
+void GameObject::OnCollide(GameObject& other)
+{
+  for (auto& e : componentList) {
+    e->OnCollide(*this, other);
+  }
+}
+
+/**
+* スプライトデータを追加する
+*/
+void GameObject::AddSprite(const Texcoord& tc,
+  float x, float y, float scale, float rotation)
+{
+  spriteList.push_back({ x, y, 0, 0, tc });
+}
```

ゲームオブジェクトのイベント関数は、イベントに対応するコンポーネントのメンバ関数を呼び出します。

### 1.4 エンジンにゲームオブジェクト配列を追加する

ゲームオブジェクトはエンジンクラスが管理します。`Engine.h`を開き、`GameObject.h`をインクルードしてください。

```diff
 #include "Sprite.h"
 #include "Scene.h"
 #include "TileMap.h"
+#include "GameObject.h"
 #include <GLFW/glfw3.h>
 #include <string>
```

次に、エンジンクラスの定義に次のプログラムを追加してください。

```diff
   float bgBaseX = 16; // 背景の配置開始X座標
   float bgBaseY = 16; // 背景の配置開始Y座標

   ScenePtr scene; // 実行中のシーン
+
+  // ゲームオブジェクトの配列
+  GameObjectList gameObjectList;
 };

 #endif // ENGINE_H_INCLUDED
```

それから、`gameObjectList`(ゲームオブジェクト・リスト)の容量を予約しておきます。`Engine.cpp`を開き、`Initialize`メンバ関数の定義に次のプログラムを追加してください。

```diff
   // 乱数を初期化
   std::random_device rd; // 真の乱数を生成するオブジェクト(遅い)
   rg.seed(rd()); // 疑似乱数を「真の乱数」で初期化
+
+  // ゲームオブジェクト配列の容量を予約
+  gameObjectList.reserve(1000);

   // 最初のシーンを作成して初期化
   scene = std::make_shared<MainGameScene>();
```

### 1.5 ゲームオブジェクトを操作する機能を追加する

続いて、ゲームオブジェクトを作成する関数を定義します。`Engine.h`を開き、エンジンクラスの定義に次のプログラムを追加してください。

```diff
   // 配置データの読み込み・スプライト設定
   TileMap LoadTileMap(const char* filename);
   void SetSpriteList(const TileMap& tileMap);
+
+  /**
+  * ゲームオブジェクトを作成する
+  */
+  template<typename T>
+  std::shared_ptr<T> Create(const std::string& name,
+    float x = 0, float y = 0)
+  {
+    std::shared_ptr<T> p = std::make_shared<T>();
+    p->engine = this;
+    p->name = name;
+    p->x = x;
+    p->y = y;
+    gameObjectList.push_back(p);
+    return p;
+  }

 private:
   int Initialize();
   int MainLoop();
   int Finalize();
+  void UpdateGameObject(float deltaTime);
+  void RemoveGameObject();
+  void MakeSpriteListObj();

   GLFWwindow* window = nullptr; // ウィンドウオブジェクト
   const std::string title = "OpenGLGame"; // ウィンドウタイトル
```

`Create`(クリエイト)関数テンプレートは、ゲームオブジェクトを作成して`gameObjectList`(ゲーム・オブジェクト・リスト)配列に追加します。テンプレート引数には`GameObject`クラスか、その派生クラスを指定します。

`UpdateGameObject`(アップデート・ゲームオブジェクト)から`MakeSpriteListObj`(メイク・スプライト・リスト・オブジェ)までの4つのメンバ関数は、ゲームオブジェクトを使った処理を行います。

次に、新しく宣言したメンバ関数を使うプログラムを追加します。`Engin.cpp`を開き、`MainLoop`メンバ関数の定義に次のプログラムを追加してください。

```diff
     if (scene) {
       scene->Update(*this, deltaTime);
     }
+
+    // ゲームオブジェクトを更新
+    UpdateGameObject(deltaTime);
+    RemoveGameObject();
+    MakeSpriteListObj();

     // 背景をスクロールさせる
     const float scrollSpeed = 32; // スクロール速度(ピクセル毎秒)
```

### 1.6 UpdateGameObjectを定義する

ここからは、1.5節で追加したメンバ関数を順番に定義していきます。最初に`UpdateGameObject`を定義します。`Engine.cpp`を開き、`Finalize`メンバ関数の定義の下に、次のプログラムを追加してください。

```diff
   glfwTerminate();

   return 0;
 }
+
+/**
+* ゲームオブジェクトの状態を更新
+*/
+void Engine::UpdateGameObject(float deltaTime)
+{
+  // 処理中に配列が変化しないようにコピーを作成
+  GameObjectList list = gameObjectList;
+
+  // Startイベント
+  for (auto& e : list) {
+    e->Start();
+  }
+
+  // Updateイベント
+  for (auto& e : list) {
+    if ( ! e->isDead) {
+      e->Update(deltaTime);
+    }
+  }
+}
```

`UpdateGameObject`関数は、ゲームオブジェクトの`Start`と`Update`を実行します。配列のコピーを使っているのは、`Update`と`Start`の順序が保つためです。

コピーを使わない場合、`Update`中にゲームオブジェクトを追加すると、そのゲームオブジェクトの`Start`イベントが次のフレームに遅延してしまいます。

### 1.7 RemoveGameObjectを定義する

続いて、`RemoveGameObject`(リムーブ・ゲームオブジェクト)関数を定義します。`UpdateGameObject`関数の定義の下に、次のプログラムを追加してください。

```diff
       e->Update(deltaTime);
     }
   }
 }
+
+/**
+* 死亡状態のゲームオブジェクトを削除
+*/
+void Engine::RemoveGameObject()
+{
+  const auto i = std::remove_if(
+    gameObjectList.begin(), gameObjectList.end(),
+    [](const GameObjectPtr& e) { return e->isDead; });
+
+  gameObjectList.erase(i, gameObjectList.end());
+}
```

`RemoveGameObject`関数は、死亡状態のゲームオブジェクトを配列から削除します。これには弾の削除でも使用した`remove_if`と`erase`の組み合わせを使います。

### 1.8 MakeSpriteListObjを定義する

最後に、`MakeSpriteListObj`(メイク・スプライト・リスト・オブジェ)関数を定義します。`RemoveGameObject`関数の定義の下に、次のプログラムを追加してください。

```diff
     [](const GameObjectPtr& e) { return e->isDead; });
   gameObjectList.erase(i, gameObjectList.end());
 }
+
+/**
+* ゲームオブジェクトからスプライト配列を作成
+*/
+void Engine::MakeSpriteListObj()
+{
+  // 既存の動く物体用のスプライト配列を空にする
+  spriteListObj.clear();
+
+  // 優先度が大きい順番に並び替える
+  std::stable_sort(
+    gameObjectList.begin(), gameObjectList.end(),
+    [](const GameObjectPtr& a, const GameObjectPtr& b) {
+      return a->priority > b->priority;
+    });
+
+  // ゲームオブジェクトのスプライトデータをスプライト配列に追加
+  // 同時にワールド座標へ変換する
+  for (const auto& e : gameObjectList) {
+    for (const auto& sprite : e->spriteList) {
+      spriteListObj.push_back(sprite);
+      Sprite& s = spriteListObj.back();
+      s.x += e->x;
+      s.y += e->y;
+    }
+  }
+}
```

`stable_sort`(ステーブル・ソート)関数は、配列を指定した条件で並べ替えます。

<p><code class="tnmai_code"><strong>【書式】</strong><br>
void stable_sort(範囲の先頭, 範囲の終端, 並べ替え条件);
</code></p>

「並べ替え条件」の引数は、範囲内の任意の2つの要素a, bです。aのほうが前に並ぶべきなら`true`、bのほうが前に並ぶべきなら`false`を返すように記述します。

上記のプログラムでは、優先順位の数値が大きいほうが前に並ぶように設定しています。結果として、優先度が大きい順で並べ替えが行われます。

並べ替えが終わったら、スプライトデータをスプライト配列に追加します。スプライトデータは「ローカル座標」で作られているので、ゲームオブジェクトの移動を反映(=ワールド座標に変換)しています。

スプライト配列への追加は優先順位の数値が大きい順で行われます。数値の小さい(=順位の高い)ゲームオブジェクトほど手前に表示されることになります。

順位が等しい場合、後から追加したゲームオブジェクトが手前に表示されます。

### 1.9 コンポーネント派生クラスを作成する

ゲームオブジェクトの動作はコンポーネントによって制御します。とりあえず、いくつかの基本的なコンポーネントを追加しましょう。

プロジェクトの`Src`フォルダに新しいフォルダを追加し、`Component`(コンポーネント)という名前を付けてください。

次に、プロジェクトの`Src\Component`フォルダに`Move.h`(ムーブ・エイチ)という名前のヘッダファイルを追加してください。追加したファイルを開き、次のプログラムを追加してください。

```diff
+/**
+* @file Move.h
+*/
+#ifndef MOVE_H_INCLUDED
+#define MOVE_H_INCLUDED
+#include "../Component.h"
+#include "../GameObject.h"
+
+/**
+* ゲームオブジェクトを移動する
+*/
+class Move : public Component
+{
+public:
+  Move() = default;
+  virtual ~Move() = default;
+  virtual void Update(GameObject& gameObject, float deltaTime) override {
+    gameObject.x += vx * deltaTime;
+    gameObject.y += vy * deltaTime;
+  }
+
+  float vx = 0;
+  float vy = 0;
+};
+
+#endif // MOVE_H_INCLUDED
```

続いて、プロジェクトの`Src\Component`フォルダに`OutOfScreen.h`(アウト・オブ・スクリーン・エイチ)という名前のヘッダファイルを追加してください。追加したフィアルを開き、次のプログラムを追加してください。

```diff
+/**
+* @file OutOfScreen.h
+*/
+#ifndef OUTOFSCREEN_H_INCLUDED
+#define OUTOFSCREEN_H_INCLUDED
+#include "../Component.h"
+#include "../GameObject.h"
+
+/**
+* 画面外と判定されたオブジェクトを削除する
+*/
+class OutOfScreen : public Component
+{
+public:
+  OutOfScreen() = default;
+  virtual ~OutOfScreen() = default;
+  virtual void Update(GameObject& gameObject, float deltaTime) override {
+    const float xMin = -32;
+    const float xMax = 18 * 32;
+    const float yMin = -32;
+    const float yMax = 23 * 32;
+    if (gameObject.x <= xMin || gameObject.x >= xMax ||
+      gameObject.y <= yMin || gameObject.y >= yMax) {
+      gameObject.isDead = true;
+    }
+  }
+};
+
+#endif // OUTOFSCREEN_H_INCLUDED
```

### 1.10 自機をゲームオブジェクトにする

ここまでのプログラミングによって、自機や敵などのスプライトは、ゲームオブジェクト経由で作成されるように変化しました。この変化に対応するために、自機と敵をゲームオブジェクトで管理するように変更します。

最初に、`Scene`の派生クラスがゲームオブジェクトを扱えるように、先行宣言を追加します。`Scene.h`を開き、次のプログラムを追加してください。

```diff
 #include <memory>

 // 先行宣言
 class Engine;
+class GameObject;
+using GameObjectPtr = std::shared_ptr<GameObject>;

 /**
 * シーンの基底クラス
```

それでは、スプライトをゲームオブジェクトに変更していきましょう。`MainGameScene.h`を開き、次のプログラムを追加してください。

```diff
   float shotTimer = 0;  // 弾の発射間隔タイマー
   TileMap enemyMap;     // 敵出現データ
   size_t spawningY = 0; // 敵出現ライン
+  GameObjectPtr player; // プレイヤー
 };

 #endif // MAINGAMESCENE_H_INCLUDED
```

これまで自機は「0番目のスプライト」としていました。番号ごとに役割を決めるのは、簡単な操作程度なら十分に機能します。

しかし、ちょっとでも複雑なプログラムをしようとすると、すぐに行き詰まってしまいます。そこで、ゲームオブジェクトはポインタで管理するようにします。

次にヘッダファイルをインクルードします。`MainGameScene.cpp`を開き、次のプログラムを追加してください。

```diff
 * @file MainGameScene.cpp
 */
 #include "MainGameScene.h"
+#include "Component/Move.h"
+#include "Component/OutOfScreen.h"
+#include "GameObject.h"
 #include "Engine.h"
 #include <fstream>
```

これで、`GameObject`クラスのメンバが使えるようになりました。まずは自機を作成します。`Initialize`関数にある自機スプライトを追加するプログラムを、次のように変更してください。

```diff
   GLFWwindow* window = engine.GetWindow();
   const auto [bgSizeX, bgSizeY, bgBaseX, bgBaseY] = engine.GetBgSize();

-  // 自機スプライトを追加
-  spriteListObj.push_back({
-    static_cast<float>(bgSizeX) * 32 / 2, 64, 0, 0,
-    MakeTexcoord(0, 464, 32, 48) });
+  // 自機を追加
+  player = engine.Create<GameObject>("player",
+    static_cast<float>(bgSizeX) * 32 / 2, 64);
+  player->AddSprite(MakeTexcoord(0, 464, 32, 48));

   // 敵配置データを読み込む
   enemyMap = engine.LoadTileMap("Res/map01_obj.csv");
```

次に、`UpdatePlayer`関数を次のように変更してください。

```diff
 void MainGameScene::UpdatePlayer(Engine& engine, float deltaTime)
 {
-  SpriteList& spriteListObj = engine.GetSpriteListObj();
-  Sprite* player = &spriteListObj[0];
-
   // キー入力を移動方向に変換
   const float vx = static_cast<float>(
```

### 1.11 弾をゲームオブジェクトにする

自機が発射する弾をゲームオブジェクトにします。`UpdatePlayer`関数にある弾を発射するプログラムを、次のように変更してください。

```diff
     shotTimer -= deltaTime; // キーが押されている間タイマーを減らす
     if (shotTimer <= 0) {   // タイマーが0以下になったら弾を発射
-      spriteListObj.push_back({
-        player->x, player->y, 0, 0, tcBullet });
+      GameObjectPtr bullet = engine.Create<GameObject>(
+        "bullet", player->x, player->y);
+      bullet->AddSprite(tcBullet);
+      auto move = bullet->AddComponent<Move>();
+      move->vy = 1000;
+      bullet->AddComponent<OutOfScreen>();
       shotTimer += 0.2f; // 弾の発射間隔を設定(秒)
     }
   } else {
```

弾の移動は`Move`コンポーネント、画面外に出た弾の削除は`OutOfScreen`コンポーネントがやってくれますので、もはや、`UpdatePlayer`関数の同じことをするプログラムは不要です。

弾を発射するプログラムの下にある、弾を移動するプログラムと弾を削除するプログラムを削除してください。

```diff
     // 次にキーが押されたら、すぐ弾が発射されるようにする
     shotTimer = 0;
   }
-
-  // 弾を移動
-  const float bulletSpeed = 1000 * deltaTime;
-  for (auto& e : spriteListObj) {
-    if (e.texcoord.u == tcBullet.u && e.texcoord.v == tcBullet.v) {
-      e.y += bulletSpeed;
-    }
-  }
-
-  // 画面内にある弾を配列の前側に集める
-  const auto i = std::remove_if(spriteListObj.begin(), spriteListObj.end(),
-    [tcBullet](const Sprite& e) {
-      return e.texcoord.u == tcBullet.u && e.texcoord.v == tcBullet.v &&
-        IsOutOfScreen(e.x, e.y); });
-
-  // 配列の後ろ側を削除する
-  spriteListObj.erase(i, spriteListObj.end());
 }

 /**
 * 敵を出現させる
```

これで弾をゲームオブジェクトにすることができました。

### 1.12 敵をゲームオブジェクトにする

```diff
         // 実際の出現位置に敵を配置(配置データは画像の右下を指している)
         const Texcoord& tc = texcoordList[enemyId];
-        spriteListObj.push_back({
-          static_cast<float>(x * 32 + tc.sx * 512 / 2),
-          static_cast<float>(21 * 32 + tc.sy * 512 / 2),
-          0, 0, tc });
+        GameObjectPtr enemy = engine.Create<GameObject>(
+          "enemy",
+          static_cast<float>(x * 32 + tc.sx * 512 / 2),
+          static_cast<float>(21 * 32 + tc.sy * 512 / 2));
+        enemy->AddSprite(tc);
+        auto move = enemy->AddComponent<Move>();
+        move->vy = -100;
+        enemy->AddComponent<OutOfScreen>();
       }
     } // for x
   } // for spawningY
```

この変更によって、敵の移動もコンポーネントがやってくれるようになります。そこで、`Update`関数にある敵を移動させるプログラムを削除してください。

```diff
   UpdatePlayer(engine, deltaTime);
   SpawnEnemy(engine);
-
-  // 敵を動かす(仮)
-  const float enemySpeed = 100 * deltaTime;
-  SpriteList& spriteListObj = engine.GetSpriteListObj();
-  for (auto& e : spriteListObj) {
-    if (e.texcoord.v <= 256.0f / 512) {
-      e.y -= enemySpeed;
-    }
-  }
 }

 /**
 * 自機の状態を更新
```

プログラムが書けたらビルドして実行してください。スプライトで表示していたときと全く同じように動いていたら成功です。

### 1.13 表示優先度

現在、自機は敵や弾の下に表示されています。しかし、これは悪い設計です。自機がほかのスプライトに隠されてしまうと、ユーザーは勘で避けるほかなくなってしまいます。

そのため、自機はほぼ常にユーザーから見えているべきです。

あるゲームオブジェクトを別のゲームオブジェクトの手前に表示したい場合、手前に表示したいゲームオブジェクトの優先順位を上げるか、奥に表示したいゲームオブジェクトの優先順位を下げます。

まず優先順位を決めましょう。`MainGameScene.cpp`の先頭に、次のプログラムを追加してください。

```diff
 #include "Engine.h"
 #include <fstream>
 #include <filesystem>
+
+// 表示優先順位
+// 上にいくほど高く、下に行くほど低い
+enum SpritePriority
+{
+  prioPlayer,       // 自機
+  prioPlayerBullet, // 自機の弾
+  prioEnemy,        // 敵
+};

 // テクスチャ座標のリスト
 const Texcoord texcoordList[] = {
```

次に、`Initialize`関数にある自機を追加するプログラムに、優先順位を設定するプログラムを追加してください。

```diff
   // 自機を追加
   player = engine.Create<GameObject>("player",
     static_cast<float>(bgSizeX) * 32 / 2, 64);
+  player->priority = prioPlayer;
   player->AddSprite(MakeTexcoord(0, 464, 32, 48));

   // 敵配置データを読み込む
```

続いて、`UpdatePlayer`関数にある弾を発射するプログラムに、優先順位を設定するプログラムを追加してください。

```diff
    if (shotTimer <= 0) {   // タイマーが0以下になったら弾を発射
       GameObjectPtr bullet = engine.Create<GameObject>(
         "bullet", player->x, player->y);
+      bullet->priority = prioPlayerBullet;
       bullet->AddSprite(tcBullet);
       auto move = bullet->AddComponent<Move>();
```

同様に`SpawnEnemy`関数にある敵を出現させるプログラムに、優先順位を設定するプログラムを追加してください。

```diff
           "enemy",
           static_cast<float>(x * 32 + tc.sx * 512 / 2),
           static_cast<float>(21 * 32 + tc.sy * 512 / 2));
+        enemy->priority = prioEnemy;
         enemy->AddSprite(tc);
         auto move = enemy->AddComponent<Move>();
```

プログラムが書けたらビルドして実行してください。自機と敵が重なったとき、自機のほうが手前に表示されていたら成功です。

>**【1章のまとめ】**
>
>* 
>* 
>* 

<div style="page-break-after: always"></div>

## 2. 衝突判定

### 2.1 長方形クラスを作る

「衝突判定データ」には長方形を使います。長方形は英語で`Rectangle`(レクタングル)といいますが、ちょっと長すぎるので、`Rect`(レクト)という短縮形がよく使われます。

本テキストでも長方形を表す構造体を作り、`Rect`と名付けることにしました。プロジェクトの`Src`フォルダに`Rect.h`(レクト・エイチ)という名前のヘッダファイルを追加してください。追加したファイルを開き、次のプログラムを追加してください。

```diff
+/**
+* @file Rect.h
+*/
+#ifndef RECT_H_INCLUDED
+#define RECT_H_INCLUDED
+#include <vector>
+
+/**
+* 2Dの長方形
+*/
+struct Rect
+{
+  float min[2];
+  float max[2];
+};
+
+// 2D長方形の配列
+using RectList = std::vector<Rect>;
+
+/**
+* 長方形の座標を移動させる
+*/
+inline Rect Add(const Rect& r, float x, float y)
+{
+  return { r.min[0] + x, r.min[1] + y, r.max[0] + x, r.max[1] + y };
+}
+
+/**
+* 2つの長方形が重なっているか調べる
+*
+* @retval true  重なっている
+* @retval false 重なっていない
+*/
+inline bool Overlap(const Rect& a, const Rect& b)
+{
+  return
+    a.min[0] <= b.max[0] && b.min[0] <= a.max[0] &&
+    a.min[1] <= b.max[1] && b.min[1] <= a.max[1];
+}
+
+/**
+* 2つの長方形配列が重なっているか調べる
+*
+* @retval true  重なっている
+* @retval false 重なっていない
+*/
+inline bool Overlap(const RectList& ra, const RectList& rb) 
+{
+  for (const auto& a : ra) {
+    for (const auto& b : rb) {
+      if (Overlap(a, b)) {
+        return true;
+      }
+    }
+  }
+  return false;
+}
+
+#endif // RECT_H_INCLUDED
```

長方形は図形として単純すぎるため、単独では複雑な形状を表すことができません。そこで、`RectList`(レクト・リスト)という長方形の配列を定義しました。

複数の長方形を組み合わせることによって、それなりに複雑な形状を表現することができます。

### 2.2 ゲームオブジェクトに衝突判定を追加する

`Rect`構造体使って、ゲームオブジェクトに衝突判定を定義します。`GameObject.h`を開き、ゲームオブジェクトクラスの定義に、次のプライベートメンバ変数を追加してください。

```diff
 private:
   // クラス外で勝手に操作されると困る変数
   bool isStarted = false;     // Start実行済みフラグ
+  RectList collisionList;     // コリジョン配列
+  Rect aabb = { 0, 0, 0, 0 }; // コリジョン境界ボックス
 };
 
 #endif // GAMEOBJECT_H_INCLUDED
```

コリジョン境界ボックスは、「コリジョン配列に含まれる、全ての長方形を囲む、最少の長方形」です。このような長方形のことを「境界ボックス」といいます。

「境界ボックス」は英語ではAxis Aligned Bounding Box(アクシス・アラインド・バウンディング・ボックス)と呼ばれますが、長いので`AABB`(エーエービービー)と短縮されることが多いです。

境界ボックスは衝突判定を高速に行うための工夫です。ゲーム中に数百のゲームオブジェクトが登場するとしても、そのほとんどは近くにあるわずかなゲームオブジェクトとしか衝突しません。

そこで、まず「境界ボックス」同士の衝突判定を行います。境界ボックス同士が交差していない場合、コリジョン配列の衝突判定を行う必要はありません。

これは、コリジョン配列に多数の長方形が含まれる場合に有効な手法です。逆に、ほとんどのゲームオブジェクトがひとつの長方形しか持っていない場合は効率が下がります。

### 2.3 ゲームオブジェクトにコリジョン操作関数を追加する

続いて、コリジョンを追加したり取得する関数を追加します。`GameObject`クラスの定義に、次のパブリックメンバ関数を追加してください。

```diff
     float x = 0, float y = 0, float scale = 1, float rotation = 0);
   const SpriteList& GetSprite() const { return spriteList; }
+
+  // コリジョンの操作
+  void AddCollision(const Rect& r);
+  const RectList& GetCollision() const { return collisionList; }
+  const Rect& GetAabb() const { return aabb; }

   // コンポーネントの操作
   template<typename T>
```

次に`GameObject.cpp`を開き、`AddSprite`メンバ関数の定義の下に、次のプログラムを追加してください。

```diff
 {
   spriteList.push_back({ x, y, 0, 0, tc });
 }
+
+/**
+* コリジョンデータを追加する
+*/
+void GameObject::AddCollision(const Rect& r)
+{
+  collisionList.push_back(r);
+
+  // 境界ボックスを更新
+  aabb.min[0] = std::min(aabb.min[0], r.min[0]);
+  aabb.min[1] = std::min(aabb.min[1], r.min[1]);
+  aabb.max[0] = std::max(aabb.max[0], r.max[0]);
+  aabb.max[1] = std::max(aabb.max[1], r.max[1]);
+}
```

### 2.4 CollideGameObjectを定義する

ゲームオブジェクトクラスの準備が終わったので、次はエンジンクラスにコリジョン機能を追加します。

`Engine.h`を開き、エンジンクラスの定義に、次のプライベートメンバ関数の宣言を追加してください。

```diff
   int MainLoop();
   int Finalize();
   void UpdateGameObject(float deltaTime);
+  void CollideGameObject();
   void RemoveGameObject();
   void MakeSpriteListObj();
```

`CollideGameObject`(コライド・ゲームオブジェクト)関数は、ゲームオブジェクトの衝突判定を行い、衝突していたら衝突イベント関数を呼び出します。

次に衝突判定を呼び出します。`Engine.cpp`を開き、`MainLoop`関数の定義に次のプログラムを追加してください。

```diff
     // ゲームオブジェクトを更新
     UpdateGameObject(deltaTime);
+    CollideGameObject();
     RemoveGameObject();
     MakeSpriteListObj();
```

衝突判定をどのタイミングで行うかは、ゲームエンジンの設計によります。一般的にはゲームオブジェクトの更新直後に行います。ゲームの状態をユーザーに通知するための最速のタイミングだからです。

現在作成しているエンジンの場合、`UpdateGameObject`でゲームオブジェクトの状態を更新しています。そこで、その直後に衝突判定を実行することにしました。

それでは、`CollideGameObject`(コライド・ゲームオブジェクト)関数を定義しましょう。`UpdateGameObject`関数の定義の下に、次のプログラムを追加してください。

```diff
       e->Update(deltaTime);
     }
   }
 }
+
+/**
+* ゲームオブジェクトの衝突判定
+*/
+void Engine::CollideGameObject()
+{
+  struct WorldCollider
+  {
+    GameObject* gameObject;
+    Rect aabb;
+    std::vector<Rect> collision;
+  };
+
+  // ワールド座標のコライダーを計算
+  std::vector<WorldCollider> tmp;
+  tmp.reserve(gameObjectList.size());
+  for (auto& e : gameObjectList) {
+    // Startしていないか死んでいるゲームオブジェクトは衝突しない
+    if ( ! e->IsStarted() || e->isDead) {
+      continue;
+    }
+
+    // ワールド座標 = ローカル座標 + ゲームオブジェクトの座標
+    const RectList& local = e->GetCollision();
+    WorldCollider world;
+    world.gameObject = e.get();
+    world.aabb = Add(e->GetAabb(), e->x, e->y);
+    world.collision.resize(local.size());
+    for (size_t i = 0; i < local.size(); ++i) {
+      world.collision[i] = Add(local[i], e->x, e->y);
+    }
+    tmp.push_back(world);
+  }
+
+  // コライダーの衝突判定
+  for (auto pa = tmp.begin(); pa != tmp.end(); ++pa) {
+    for (auto pb = pa + 1; pb != tmp.end(); ++pb) {
+      if ( ! Overlap(pa->aabb, pb->aabb)) {
+        continue; // 衝突していない
+      }
+      if ( ! Overlap(pa->collision, pb->collision)) {
+        continue; // 衝突していない
+      }
+      // 衝突しているので、衝突イベント関数を実行
+      pa->gameObject->OnCollide(*pb->gameObject);
+      pb->gameObject->OnCollide(*pa->gameObject);
+    }
+  }
+}

 /**
 * 死亡状態のゲームオブジェクトを削除
```

ゲームオブジェクトに設定されているコライダーは、ゲームオブジェクトが原点にあるときの座標で作られます。

正しい衝突判定を行うためには、すべてのゲームオブジェクトの座標をコライダーの座標に反映し、移動後のコライダー座標を使って衝突判定を行う必要があります。

上記のプログラムでは、ゲームオブジェクトが原点にあるときの座標を「ローカル座標」、ゲームオブジェクトの座標を反映したあとの座標を「ワールド座標」と呼んでいます。

`WorldCollider`(ワールド・コライダー)構造体は、ワールド座標に変換したコライダーを保持するためのものです。

衝突判定は数百回または数千回実行される可能性があるので、判定のたびにワールド座標へ変換する計算を行うと、そのぶん処理に時間がかかってしまいます。そこで、事前に変換を済ませておきます。

また、ループ中にゲームオブジェクトが追加されると、`Start`実行前のゲームオブジェクトが衝突判定に入り込んでしまいます。さらに、既に死んでいる場合も衝突判定を行う必要はありません。

そこで、`WorldCollider`にゲームオブジェクトのアドレスをコピーし、それを衝突判定に使います。Start前と死んでいるゲームオブジェクトは、コピーを作成する段階で除外しておきます。

この工夫によって、まだ`Start`していなかったり死んでいるゲームオブジェクトと、通常のゲームオブジェクトが衝突しないようにしています。

### 2.5 コライダーを設定する

ゲームオブジェクトに衝突判定を追加します。`Initialize`関数にある自機を追加するプログラムに、コライダーを追加するプログラムを追加してください。

```diff
     "player", static_cast<float>(bgSizeX) * 32 / 2, 64);
   player->priority = prioPlayer;
   player->AddSprite(MakeTexcoord(0, 464, 32, 48));
+  player->AddCollision({ -3, -4, 3, 4 });

   // 敵配置データを読み込む
   enemyMap = engine.LoadTileMap("Res/map01_obj.csv");
```

現在のシューティングゲームでは自機の衝突判定は、見た目に対してかなり小さく設定されています。これは「避けられないと思ったのに避けられた」というプレイ体験を生まれやすくするためです。

それにならって上記のプログラムでも、自機の中央付近に小さな衝突判定を作るだけにしています。

次に、`UpdatePlayer`関数にある自機の弾を発射するプログラムに、コライダーを追加するプログラムを追加してください。

```diff
         "bullet", player->x, player->y);
       bullet->priority = prioPlayerBullet;
       bullet->AddSprite(tcBullet);
+      bullet->AddCollision({ -8, -16, 8, 16 });
       auto c = bullet->AddComponent<Move>();
       c->vy = 1000;
```

自機の弾は見た目より大きな衝突判定を付けます。後述しますが、敵の衝突判定は(自機ほどではないものの)見た目より少し小さく設定することが多いです。これは、自機と接触する可能性を下げるためです。

しかしその結果、弾の衝突判定を見た目どおりに付けてしまうと「見た目では敵と弾が重なっているのに衝突していない」という状況が生まれます。これを避けるには、弾の衝突判定を大きくします。

最後に敵の衝突判定を設定します。`SpawnEnemy`関数に次のプログラムを追加してください。

```diff
           static_cast<float>(21 * 32 + tc.sy * 512 / 2));
         enemy->priority = prioEnemy;
         enemy->AddSprite(tc);
+        const float collisionSize = 512 * 0.4f;
+        enemy->AddCollision({
+          -tc.sx * collisionSize, -tc.sy * collisionSize,
+           tc.sx * collisionSize,  tc.sy * collisionSize });
         auto move = enemy->AddComponent<Move>();
         move->vy = -100;
```

敵は種類によって見た目が大きく異なるため、衝突判定の大きさも種類によって変わるはずです。本来であれば、テクスチャ座標配列のようにコライダー配列を用意するべきでしょう。

しかし今回は手抜きをして、「画像サイズの80%」の大きさを設定しています。特殊な形状でない限り、ある程度それらしい衝突判定になると思います。

### 2.6 エネミーコンポーネントを追加する

衝突が起きると、ゲームエンジンによって`OnCollide`(オン・コライド)関数が呼び出されます。弾が当たった敵を消すために`OnCollide`をオーバーライドしたコンポーネントを作成します。

プロジェクトの`Src/Component`フォルダに`Enemey.h`(エネミー・エイチ)という名前のヘッダファイルを追加してください。追加したファイルを開き、次のプログラムを追加してください。

```diff
+/**
+* @file Enemy.h
+*/
+#ifndef ENEMY_H_INCLUDED
+#define ENEMY_H_INCLUDED
+#include "../Component.h"
+#include "../GameObject.h"
+
+/**
+* 敵コンポーネント
+*/
+class Enemy: public Component
+{
+public:
+  Enemy() = default;
+  virtual ~Enemy() = default;
+  virtual void OnCollision(GameObject& gameObject, GameObject& other) override
+  {
+    if (other.name != "bullet") {
+      return;
+    }
+    --gameObject.health;
+    if (gameObject.health > 0) {
+      return;
+    }
+    gameObject.isDead = true;
+  }
+};
+
+#endif // ENEMY_H_INCLUDED
```

`Enemy`コンポーネントは、`causerName`(コーザー・ネーム)と同じ名前を持つゲームオブジェクトと衝突すると、自身が割り当てられているゲームオブジェクトの`health`を減らします。

次に`MainGameScene.cpp`を開き、`Enemy.h`をインクルードしてください。

```diff
 #include "MainGameScene.h"
 #include "Component/Move.h"
 #include "Component/OutOfScreen.h"
+#include "Component/Enemy.h"
 #include "GameObject.h"
 #include "Engine.h"
```

続いて、`SpawnEnemy`関数に次のプログラムを追加してください。

```diff
            tc.sx * 512 * 0.4f,  tc.sy * 512 * 0.4f });
         auto move = enemy->AddComponent<Move>();
         move->vy = -100;
+        enemy->AddComponent<Enemy>();
       }
     } // for x
```

プログラムが書けたらビルドして実行してください。弾が敵にあたったとき、敵が消えたら成功です。

### 2.7 爆発を表示する

敵が消えるだけでは味気ないので、爆発を表示しましょう。プロジェクトの`Src\Component`フォルダに、`Animator2D.h`(アニメーター・ツーディ・エイチ)という名前のヘッダファイルを追加してください。

追加したファイルを開き、次のプログラムを追加してください。

```diff
+/**
+* @file Animator2D.h
+*/
+#ifndef ANIMATOR2D_H_INCLUDED
+#define ANIMATOR2D_H_INCLUDED
+#include "../Component.h"
+#include "../GameObject.h"
+#include "../Sprite.h"
+#include <vector>
+#include <algorithm>
+
+/**
+* 2Dアニメーションコンポーネント
+*/
+class Animator2D : public Component
+{
+public:
+  Animator2D() = default;
+  virtual ~Animator2D() = default;
+  virtual void Update(GameObject& gameObject, float deltaTime) override
+  {
+    // データがない場合は何もしない
+    if (clip.empty()) {
+      return;
+    }
+
+    // 経過時間を更新
+    timer += deltaTime;
+
+    // 再生位置を計算
+    const int size = static_cast<int>(clip.size());
+    int i = static_cast<int>(timer / interval);
+    if (loopTime) {
+      i %= size; // ループ再生
+    } else {
+      // アニメ終了時、killWhenEndフラグがtrueならゲームオブジェクトを削除
+      if (i >= size && killWhenEnd) {
+        gameObject.isDead = true;
+      }
+      i = std::clamp(i, 0, size - 1);
+    }
+
+    // スプライトデータを再生位置のデータに更新
+    gameObject.spriteList = clip[i];
+  }
+
+  bool loopTime = true; // ループ再生の有無
+  bool killWhenEnd = false; // アニメ終了時にゲームオブジェクトを削除
+  float timer = 0; // 経過時間(秒)
+  float interval = 0.1f; // フレームを進める間隔(秒)
+  std::vector<SpriteList> clip; // アニメーションクリップ
+};
+
+#endif // ANIMATOR2D_H_INCLUDED
```

次に`Enemy.h`を開き、ヘッダファイルをインクルードしてください。

```diff
 #define ENEMY_H_INCLUDED
 #include "../Component.h"
 #include "../GameObject.h"
+#include "../Engine.h"
+#include "Animator2D.h"

 /**
 * 敵コンポーネント
```

続いて、爆発を表示するゲームオブジェクトを作成します。`OnCollide`関数の定義に次のプログラムを追加してください。

```diff
       return;
     }
     gameObject.isDead = true;
+
+    // 爆発を表示
+    auto blast = gameObject.engine->Create<GameObject>(
+      "blast", gameObject.x, gameObject.y, 0.5f);
+    blast->AddSprite(MakeTexcoord(320, 368, 32, 32));
+    auto anim = blast->AddComponent<Animator2D>();
+    anim->clip.resize(6);
+    for (size_t i = 0; i < anim->clip.size(); ++i) {
+      anim->clip[i].push_back({ 0, 0, 1, 0,
+        MakeTexcoord(320 + 32 * static_cast<float>(i), 368, 32, 32) });
+    }
   }
 };
```

プログラムが書けたらビルドして実行してください。敵を撃ち落とした座標に爆発が表示されていたら成功です。

### 2.8 アニメーション終了時に削除する

`Animator2D`コンポーネントの初期状態では、アニメーションが無限にループ再生します。爆発は1回だけで十分なので、ループを止めましょう。`OnCollide`関数に次のプログラムを追加してください。

```diff
       "blast", gameObject.x, gameObject.y, 0.5f);
     blast->AddSprite(MakeTexcoord(320, 368, 32, 32));
     auto anim = blast->AddComponent<Animator2D>();
+    anim->loopTime = false; // ループ再生をしない
+    anim->killWhenEnd = true; // 再生完了時にゲームオブジェクトを削除
     anim->clip.resize(6);
     for (size_t i = 0; i < anim->clip.size(); ++i) {
```

プログラムが書けたらビルドして実行してください。爆発がループ再生されず、1回だけ表示されたら成功です。

>**【2章のまとめ】**
>
>* 
>* 
>* 

<div style="page-break-after: always"></div>

## 3. 

### 3.1 

>**【3章のまとめ】**
>
>* 
>* 
>* 

<div style="page-break-after: always"></div>
