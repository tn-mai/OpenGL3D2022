[OpenGL 3D 2022 後期 第08回]

# OBBとカプセルの衝突判定

## 習得目標

* 
* 
* 

## 1. 有向境界ボックス(OBB)同士の衝突判定

### 1.1 分離軸判定と分離超平面定理

OBBの衝突判定には「分離軸判定(ぶんりじく・はんてい)」という方法を使います。分離軸判定は「分離超平面定理(ぶんり・ちょうへいめん・ていり)」という数学の定理から導かれたものです。

分離超平面定理を簡単に説明すると、次のようになります。

>2つの「凹んだ部分のない図形」が交差していないなら、図形の間には必ず平面を入れる隙間がある。

なお、上記を数学的に言いかえると以下になります。

>互いに素の閉凸集合の間には、1つの超平面が存在できる。この超平面を「分離超平面」という。

* 互いに素 = 交差していない
* 閉凸集合 = 集合内の任意の2点を結ぶ直線が、常に元の集合に属する集合 = 凹んだ部分のない図形
* 超平面 = n次元空間におけるn-1次元の部分空間 = 3次元では単なる平面を意味する

分離軸判定は分離超平面定理を利用して、以下のように2つの図形の衝突判定を行います。

>1. 分離超平面が存在する可能性のある全ての軸について、2つの図形の頂点座標を射影する。
>2. 射影した結果に重複した部分がない場合、その軸には分離超平面が存在する(=衝突していない)。
>3. すべての軸について重複した部分が存在する場合、分離超平面は存在しない(=衝突している)。

### 1.2 OBBの頂点座標を取得する関数を定義する

分離軸判定は、頂点座標を軸に射影することで判定を行います。この判定には「図形の頂点座標」が必要なので、まずはOBBの頂点座標を計算する関数を定義します。

関数名は`GetVertices`(ゲット・バーティシーズ, verticesはvertexの複数形)とします。`Collision.cpp`を開き、`Collision`名前空間の先頭に次のプログラムを追加してください。

>コメントに書いてある模式図は、頂点座標のインデックスを視覚化したものです。このような図は、あとでプログラムを見直すときに役立ちます。

```diff
 using namespace VecMath;

 namespace Collision {
+
+// 無名名前空間
+namespace {
+
+/**
+* OBBの頂点座標を取得する
+*
+* @param box 頂点座標を求めるOBB
+*
+* @return boxの頂点座標配列
+*
+*   5----4
+*  /|   /|
+* 1----0 |
+* | 7--|-6
+* |/   |/
+* 3----2
+*/
+std::vector<vec3> GetVertices(const Box& box)
+{
+  const vec3 ax = box.axis[0] * box.scale.x;
+  const vec3 ay = box.axis[1] * box.scale.y;
+  const vec3 az = box.axis[2] * box.scale.z;
+  return {
+    box.p + ax + ay + az, // 0
+    box.p - ax + ay + az, // 1
+    box.p + ax - ay + az, // 2
+    box.p - ax - ay + az, // 3
+    box.p + ax + ay - az, // 4
+    box.p - ax + ay - az, // 5
+    box.p + ax - ay - az, // 6
+    box.p - ax - ay - az  // 7
+  };
+}
+
+} // unnamed namespace

 /**
 * AABB同士の交差判定
```

今のところ、`GetVertices`関数は`Collision.cpp`でしか使う予定がありません。そこで、「無名名前空間」にしています。

>**【無名名前空間の用途】**<br>
>無名名前空間は、「ソースファイルごとに固有の名前空間」です。無名名前空間の中の定義は、同じ名前であっても、ファイルが異なれば別の定義として扱われます。これによって、定義の重複によるリンカーエラーを防ぐことができます。

### 1.3 OBBを軸に射影する関数を定義する

次に、OBBの頂点を軸に射影する関数を定義します。射影は英語で`Project`(プロジェクト)なので、関数名は`ProjectBoxToAxis`(プロジェクト・ボックス・トゥ・アクシス)とします。

`GetVertices`関数の定義の下に、次のプログラムを追加してください。

```diff
     box.p - ax - ay - az  // 7
   };
 }
+
+/**
+* OBBの頂点を軸に射影し、最大値と最小値を求める
+*
+* @param vertices OBBの頂点配列
+* @param axis     射影先の軸ベクトル
+* @param min      最小値を格納する変数
+* @param max      最大値を格納する変数
+*/
+void ProjectBoxToAxis(const vec3* vertices, const vec3& axis,
+  float& min, float& max)
+{
+  min = max = dot(axis, vertices[0]);
+  for (int i = 0; i < 8; ++i) {
+    float f = dot(axis, vertices[i]);
+    min = std::min(min, f);
+    max = std::max(max, f);
+  }
+}
 
 } // unnamed namespace
```

座標をベクトルに射影するには「内積」を使います。

### 1.4 交差している距離を求める関数を定義する

次に、`ProjectBoxToAxis`関数を使って、射影したOBBの交差を調べる関数を定義します。「2つのOBBが交差した距離」を返す関数なので、名前は`GetIntersectionLength`(ゲット・インターセクション・レングス)とします(`Intersection`は「交差」という意味)。

`ProjectBoxToAxis`関数の定義の下に、次のプログラムを追加してください。

```diff
     max = std::max(max, f);
   }
 }
+
+/**
+* 2つのOBBを軸ベクトルに射影し、交差している距離を求める
+*
+* @param verticesA  OBBその1の頂点配列
+* @param verticesB  OBBその2の頂点配列
+* @param axis       射影先の軸ベクトル
+* @param shouldFlip 衝突法線の反転の有無
+*
+* @return 交差している距離(計算の都合でマイナス値になっていることに注意)
+*/
+float GetIntersectionLength(const vec3* verticesA, const vec3* verticesB,
+  const vec3& axis, bool& shouldFlip)
+{
+  // 2つのOBBを軸に射影
+  float minA, maxA, minB, maxB;
+  ProjectBoxToAxis(verticesA, axis, minA, maxA);
+  ProjectBoxToAxis(verticesB, axis, minB, maxB);
+
+  // 射影した範囲が交差していないなら0を返す
+  if (minB > maxA && minA > maxB) {
+    return 0;
+  }
+
+  // 衝突法線は「OBBその1」が左、「OBBその2」が右にあると想定しているので、
+  // 順序が逆になっている場合、衝突法施の向きを反転する必要がある、
+  // ということを、呼び出し元に伝える
+  shouldFlip = minB < minA;
+
+  // 交差している距離を計算
+  float lenA = maxA - minA;
+  float lenB = maxB - minB;
+  float min = std::min(minA, minB);
+  float max = std::max(maxA, maxB);
+  float length = max - min;
+  return length - lenA - lenB;
+}
 
 } // unnamed namespace
```

### 1.5 OBBとOBBの衝突判定関数を定義する

それではOBBとOBBの衝突判定を定義しましょう。まずは関数宣言を追加します。`Collision.h`を開き、OBBと球体の衝突判定関数の宣言の下に、次のプログラムを追加してください。

```diff
 bool Intersect(const AABB& aabb, const Sphere& sphere, ContactPoint& cp);
 bool Intersect(const Sphere& sphere, const Box& box, ContactPoint& cp);
 bool Intersect(const Box& box, const Sphere& sphere, ContactPoint& cp);
+bool Intersect(const Box& boxA, const Box& boxB, ContactPoint& cp);

 } // namespace Collision
```

次に関数を定義しますが、少し長くなるのでちょっとずつ作成していきます。`Collision.cpp`を開き、OBBと球体の衝突判定関数の定義の下に、次のプログラムを追加してください。

```diff
   }
   return false;
 }
+
+/**
+* OBBとOBBの衝突判定
+*
+* @param boxA 衝突判定を行うOBBその1
+* @param boxB 衝突判定を行うOBBその2
+* @param cp   衝突結果を格納するコンタクトポイント
+*
+* @retval true  衝突している
+* @retval false 衝突していない
+*/
+bool Intersect(const Box& boxA, const Box& boxB, ContactPoint& cp)
+{
+  // OBBの頂点座標配列を取得
+  const auto verticesA = GetVertices(boxA);
+  const auto verticesB = GetVertices(boxB);
+
+  // 貫通距離を最大にしておく
+  cp.penetration = -FLT_MAX;
+
+  // 分離軸判定用の軸ベクトルを計算
+  vec3 axisList[15] = {
+    boxA.axis[0], boxA.axis[1], boxA.axis[2],
+    -boxB.axis[0], -boxB.axis[1], -boxB.axis[2],
+  };
+  for (int i = 0; i < 3; ++i) {
+    axisList[6 + i * 3 + 0] = cross(axisList[i], axisList[3]);
+    axisList[6 + i * 3 + 1] = cross(axisList[i], axisList[4]);
+    axisList[6 + i * 3 + 2] = cross(axisList[i], axisList[5]);
+  }
+
+  return true; // 衝突している
+}

 } // namespace Collision
```

上記のプログラムでは、衝突判定を実行するために必要なデータを作成しています。3次元の分離軸判定を行うには、最低限以下の軸ベクトルが必要です。

>1. オブジェクトAのすべての面法線(OBBの場合3方向)。
>2. オブジェクトBのすべての面法線(OBBの場合3方向)。
>3. Aの全ての辺とBの全ての辺の外積によって得られるベクトル(OBB対OBBの場合3x3=9方向)。

辺同士の外積を軸ベクトルとする理由は、辺同士が衝突した場合を考えることで明らかになります。辺同士の衝突は、2つの辺の最短距離を求めることで調べられます。最短距離を結ぶベクトルは常に両辺に垂直なので、外積で代用できるというわけです。

### 1.6 分離軸判定の実装

必要なデータを作成したので、分離軸判定を実行します。15方向の分離軸について、`GetIntersectionLength`関数で交差距離を求めて分離軸かどうかを判定します。

軸ベクトルを計算するプログラムの下に、次のプログラムを追加してください。

```diff
     axisList[6 + i * 3 + 1] = cross(axisList[i], axisList[4]);
     axisList[6 + i * 3 + 2] = cross(axisList[i], axisList[5]);
   }
+
+  // すべての軸ベクトルに対して分離軸判定を実行
+  for (int i = 0; i < 15; ++i) {
+    // 外積によって作られた軸ベクトルの場合、元の軸が平行だと長さが0になる
+    // この場合、AまたはBの軸による分離軸判定と等しいのでスキップする
+    const float length2 = dot(axisList[i], axisList[i]);
+    if (length2 < 0.0001f) {
+      continue;
+    }
+
+    // 交差している距離を計算
+    bool shouldFlip;
+    float d = GetIntersectionLength(
+      verticesA.data(), verticesB.data(), axisList[i], shouldFlip);
+
+    // 距離が0以上なら分離超平面を入れる隙間がある(つまり交差していない)
+    if (d >= 0) {
+      return false; // 衝突していない
+    }
+
+    // 外積で作成した軸ベクトルの長さは1にならない(sinθなので)
+    // 結果として、dは軸ベクトルの長さを単位とした値になる
+    // しかし、単位が異なると長さを比較できないため、正規化して単位を揃える
+    // 補足: 軸ベクトルを正規化する方法もあるが、除算の回数が増えるし衝突していない場合は無駄になる
+    d /= std::sqrt(length2);
+
+    // 交差距離がより短い方向から衝突したとみなす
+    if (d > cp.penetration) {
+      cp.penetration = d;
+      // 衝突法線は軸ベクトルの逆方向
+      if (shouldFlip) {
+        cp.normal = axisList[i];
+      } else {
+        cp.normal = -axisList[i];
+      }
+    }
+  }
+
+  // 衝突法線を正規化
+  cp.normal = normalize(cp.normal);

   return true; // 衝突している
 }
```

2つのOBBの角度によっては、外積によって得られたベクトルの長さが0になることがあります。この場合2つの軸は平行であり、これはOBBの軸の判定で代用できるためスキップできます。

15方向のどれかひとつでも分離軸と判定されたら、2つのOBBは衝突していません。この場合、`false`を返して終了します。

ところで、外積で得られた軸ベクトルは、外積の性質から長さが`sinθ`になります。そのため、長さが1とは限りません。このベクトルを使って交差距離を求めると、「実際の交差距離 * 軸ベクトルの長さ」が返されます。

この状態でも交差判定自体は可能です。しかし、軸ベクトルの長さがまちまちだと長さの比較ができないため、「交差距離が最短の軸」を選ぶことができません。そこで、交差距離`d`を「軸ベクトルの長さ」で除算しています。

>別の方法として「軸ベクトルを正規化してから交差距離を求める」こともできます。しかし、ベクトルの正規化にはXYZの3要素を除算する必要があるため、計算回数が多くなります。また、交差していない場合は無駄な計算をしていることになります。

交差距離がこれまで計算された交差距離より短い場合、その軸ベクトルを衝突法線とします。本テキストでは、衝突法線の向きは「`Intersect`関数の第1引数として渡された図形」が衝突した面の法線となるように統一しています。

対して、軸ベクトルは「第1引数として渡された図形」を基準としています。これは「たまたまそうなった」だけで特別な理由はありません。とはいえ、この仕様のために、衝突法線には軸ベクトルを反転させた値を設定しています。

>軸ベクトルと衝突法線の向きを揃えることは可能です。どこを変更すればよいか考えてみると、コードの理解が深まるでしょう。

### 1.7 線分と平面を定義する

衝突判定自体はここまでの計算で完成しています。しかし、コンタクトポイントを計算しようとすると、多くのコードを追加しなくてはなりません。

OBB同士のコンタクトポイントは、交差した領域の重心になります。交差領域の重心の計算は、次の手順で行います。

>1. OBBの辺の一覧と面の一覧を作成。
>2. 2つのOBBの全ての辺について、衝突先のOBBとの交点を求める。
>3. 交点を衝突面に射影。
>4. 射影した座標の重心を求める。

TODO: ここに交差領域の図を入れる

それでは、1から順番に実装していきましょう。まず辺を表す構造体を定義します。構造体名は`LineSegment`(ライン・セグメント、「線分」という意味)とします。

`Collision.h`を開き、`Collision`名前空間の先頭に次のプログラムを追加してください。

```diff
 #include <vector>

 namespace Collision {
+
+/**
+* 線分
+*/
+struct LineSegment
+{
+  VecMath::vec3 start; // 線分の始点
+  VecMath::vec3 end;   // 線分の終点
+};

 /**
 * 軸平行境界ボックス
```

>**【直線や光線の定義について】**<br>
>始点や終点を持たない「直線」や、始点だけで終点を持たない「光線」を定義する場合、「始点と方向ベクトルの組み合わせ」のほうが扱いやすいです。

次に、面を表す構造体を追加します。平面を定義する方法は主に3種類あります。

>* 同一直線状にない3つの点。
>* 法線および、平面上の1点。
>* 法線および、原点から平面への最短距離。

プログラムでは3つ目の定義がよく使われます。float(またはdouble)型4個で済むためにデータサイズが小さく、さらに2乗数なことから現代のコンピューターシステムにとって扱いやすいためです。

それでは構造体を定義しましょう。名前は`Plane`(プレーン、「平面」という意味)とします。`LineSegment`構造体の定義の下に、次のプログラムを追加してください。

```diff
   VecMath::vec3 start; // 線分の始点
   VecMath::vec3 end;   // 線分の終点
 };
+
+/**
+* 平面
+*/
+struct Plane
+{
+  VecMath::vec3 normal; // 面の法線
+  float d; // 原点からの距離
+};

 /**
 * 軸平行境界ボックス
```

### 1.8 辺の一覧を作成する関数を定義する

これで必要な構造体は用意できました。続いて、「辺の一覧」を作成する関数を定義します。関数名は`GetEdges`(ゲット・エッジズ)とします。`Collision.cpp`を開き、`GetVertices`関数の定義の下に、次のプログラムを追加してください。

```diff
     box.p - ax - ay - az
   };
 }
+
+/**
+* OBBの辺を取得する
+*
+* @param vertices 頂点座標を求めるOBB
+*
+* @return boxの辺の配列
+*
+*   5----4
+*  /|   /|
+* 1----0 |
+* | 7--|-6
+* |/   |/
+* 3----2
+*/
+std::vector<LineSegment> GetEdges(const vec3* vertices)
+{
+  return {
+    // X軸方向
+    { vertices[0], vertices[1] },
+    { vertices[2], vertices[3] },
+    { vertices[4], vertices[5] },
+    { vertices[6], vertices[7] },
+
+    // Y軸方向
+    { vertices[0], vertices[2] },
+    { vertices[1], vertices[3] },
+    { vertices[4], vertices[6] },
+    { vertices[5], vertices[7] },
+
+    // Z軸方向
+    { vertices[0], vertices[4] },
+    { vertices[1], vertices[5] },
+    { vertices[2], vertices[6] },
+    { vertices[3], vertices[7] },
+  };
+}

 /**
 * OBBの頂点を軸に射影し、最大値と最小値を求める
```

今回の場合、辺の順序は重要ではないので、適当にX, Y, Zの順にしています。

### 1.9 面の一覧を作成する関数を定義する

続いて「面の一覧」を作成する関数を定義します。関数名は`GetPlanes`(ゲット・プレーンズ)とします。`GetEdges`関数の定義の下に、次のプログラムを追加してください。

```diff
     { vertices[3], vertices[7] },
   };
 }
+
+/**
+* OBBの面を取得する
+*
+* @param box 面を求めるOBB
+*
+* @return boxの面の配列
+*/
+std::vector<Plane> GetPlanes(const Box& box)
+{
+  const vec3 ax = box.axis[0] * box.scale.x;
+  const vec3 ay = box.axis[1] * box.scale.y;
+  const vec3 az = box.axis[2] * box.scale.z;
+  return {
+    { box.axis[0], dot(box.axis[0], box.p + ax) }, // +x
+    {-box.axis[0],-dot(box.axis[0], box.p - ax) }, // -x
+    { box.axis[1], dot(box.axis[1], box.p + ay) }, // +y
+    {-box.axis[1],-dot(box.axis[1], box.p - ay) }, // -y
+    { box.axis[2], dot(box.axis[2], box.p + az) }, // +z
+    {-box.axis[2],-dot(box.axis[2], box.p - az) }, // -z
+  };
+}
```

Plane構造体は「法線」+「原点から平面までの距離」の2つで定義されます。法線はOBBのものがそのまま使えます。「原点から平面までの距離」を求めるには、平面上の座標を面法線に射影します。

### 1.10 点がOBB内部にあるか調べる関数を定義する

続いて、「2つのOBBの全ての辺について、衝突先のOBBとの交点を求める」処理に使う、以下の関数を定義します。

>* 点がOBBの内側にあるかどうかを調べる。
>* 線分と面の交点を求める。
>* OBBの全ての辺について、もう一つのOBBの面との交点を求める

最初に「点がOBBの内側にあるかどうかを調べる」関数を定義しましょう。名前は`IsPointInsideBox`(イズ・ポイント・インサイド・ボックス、「その点はボックス内にあるか？」といった意味)とします。

`Collision.cpp`を開き、`GetIntersectionLength`関数の定義の下に、次のプログラムを追加してください。

```diff
   float length = max - min;
   return length - lenA - lenB;
 }
+
+/**
+* 点がOBB内にあるかどうかを調べる
+*
+* @param point 調べる点の座標
+* @param box   調べるOBB
+*
+* @retval true  pointはboxの内側にある
+* @retval false pointはboxの外側にある
+*/
+bool IsPointInsideBox(const vec3& point, const Box& box)
+{
+  const vec3 v = point - box.p;
+  for (int i = 0; i < 3; ++i) {
+    const float d = dot(v, box.axis[i]);
+    if (d < -box.scale[i] || d > box.scale[i]) {
+      return false; // 点はOBBの外側に有る
+    }
+  }
+  return true; // 点はOBBの内側にある
+}

 } // unnamed namespace
```

この関数の内容は、点とOBBの最近接点を求める`ClosestPoint`関数と似ています。どちらも点へ向かうベクトルを計算し、それをOBBの軸に射影することで処理を進めるからです。

### 1.11 線分と面の交点を求める関数を定義する

次に、「線分と面の交点を求める」関数を定義します。関数名は`ClipLineSegment`(クリップ・ラインセグメント、「線分を切り取る」といった意味)とします。`IsPointInsideBox`関数の定義の下に、次のプログラムを追加してください。

```diff
   }
   return true; // 点はOBBの内側にある
 }
+
+/**
+* 線分と面の交点を求める
+*
+* @param seg   線分
+* @param plane 面
+* @param p     交点を格納する変数
+*
+* @retval true  交点は線分上にある
+* @retval false 交点は線分の外にある
+*/
+bool ClipLineSegment(const LineSegment& seg, const Plane& plane, vec3& p)
+{
+  // 辺ベクトルを面法線に射影
+  const vec3 ab = seg.end - seg.start;
+  float n = dot(plane.normal, ab);
+  if (abs(n) < 0.0001f) {
+    return false; // 平行なので交差なし
+  }
+
+  // 交点までの距離を求める
+  float t = plane.d - dot(plane.normal, seg.start);
+  if (t < 0 || t > n) {
+    return false; // 交点が線分の外にあるので交差なし
+  }
+
+  // 交点座標を計算
+  t /= n; // ベクトルabに対する比率に変換
+  p = seg.start + ab * t;
+  return true;
+}

 } // unnamed namespace
```

この関数でも射影を利用して交点を求めています。最後に交点を求める際、距離`t`をベクトルabを面法線に射影した長さ`n`で除算しているのがポイントです。

`n`で割ると、`t`は「ワールド座標系の長さ」から「辺ベクトルの長さに対する比率」に変換されます。ベクトルabに「比率」を掛けることで、始点から交点までのベクトルが得られます。

### 1.12 OBB同士の交点を求める関数を定義する

最後に「作成した OBBの全ての辺について、もう一つのOBBの面との交点を求める」関数を定義します。関数名は`ClipEdges`(クリップ・エッジズ、「辺を切り取る」といった意味)とします。

`ClipLineSegment`関数の定義の下に、次のプログラムを追加してください。

```diff
   p = seg.start + ab * t;
   return true;
 }
+
+/**
+* OBBの全ての辺について、もう一つのOBBの面との交点を求める
+*
+* @param vertices OBBその1の頂点配列
+* @param box      OBBその2
+*
+* @return edgesとboxの交点
+*/
+std::vector<vec3> ClipEdges(const std::vector<vec3>& vertices, const Box& box)
+{
+  // 辺と面を取得
+  const auto edges = GetEdges(vertices.data());
+  const auto planes = GetPlanes(box);
+
+  // 交点用のメモリを予約
+  // 2つのOBBが相当深く交差していない限り、交点の数は辺の数以下になるはず
+  std::vector<vec3> result;
+  result.reserve(edges.size());
+
+  // 辺と面の交点を求める
+  for (const auto& plane : planes) {
+    for (const auto& edge : edges) {
+      vec3 p;
+      if (ClipLineSegment(edge, plane, p)) {
+        // 交点がOBBその2の内側にあるなら、有効な交点として記録
+        if (IsPointInsideBox(p, box)) {
+          result.push_back(p);
+        }
+      }
+    } // for edges
+  } // for planes
+  return result;
+}

 } // unnamed namespace
```

このプログラムは、先に定義した`GetEdges`, `GetPlanes`, `ClipLineSegment`, `IsPointInsideBox`関数を利用して、2つのOBBの交点を求めます。

>`ClipEdges`関数には最適化の余地があります。例えば、衝突法線と逆向きの面と辺は無視できるでしょう。

### 1.13 コンタクトポイントを計算する

長い準備でしたが、これでようやく必要な関数が揃いました。いよいよコンタクトポイントを計算します。OBBとOBBの衝突判定を行う`Intersect`関数の定義に、次のプログラムを追加してください。

```diff
   // 衝突法線を正規化
   cp.normal = normalize(cp.normal);
+
+  // コンタクトポイントを計算
+
+  // OBBとOBBの交点を求める
+  std::vector<vec3> c0 = ClipEdge(verticesB, boxA);
+  std::vector<vec3> c1 = ClipEdge(verticesA, boxB);
+  c0.insert(c0.end(), c1.begin(), c1.end());
+
+  // 貫通距離の中間に衝突平面を設定(衝突平面上の点pを求める)
+  float min, max;
+  ProjectBoxToAxis(verticesA.data(), cp.normal, min, max);
+  const vec3 p = boxA.p - cp.normal * (max - min + cp.penetration) * 0.5f;
+
+  // 交点を衝突平面に射影しつつ、重複する交点を削除
+  int count = 0;
+  for (int i = 0; i < c0.size(); ++i, ++count) {
+    // 交点を衝突平面に射影
+    c0[count] = c0[i] + cp.normal * dot(cp.normal, p - c0[i]);
+
+    // 重複する交点がある場合は削除
+    for (int j = 0; j < count; ++j) {
+      const vec3 v = c0[j] - c0[count];
+      if (dot(v, v) < 0.0001f) {
+        --count;
+        break;
+      }
+    }
+  }
+  c0.resize(count);
+
+  // 交点の重心を計算し、コンタクトポイントとする
+  cp.position = vec3(0);
+  for (const auto& e : c0) {
+    cp.position += e;
+  }
+  cp.position /= static_cast<float>(c0.size());
   return true; // 衝突している
 }
```

OBBとOBBの交点は`ClipEdges`関数で求めます。この関数は「第1引数で指定したOBBの辺」と「第2引数で指定したOBBの面」の交点を返します。そのため、全ての交点を求めるには、OBBを入れ替えて2回実行する必要があります。

交点を求めたら、次はコンタクトポイントを計算します。まず貫通距離の中間地点に衝突平面を定義します。次に交点を衝突平面に射影します。これによって、衝突平面上に2次元図形が作られます。

次に、求めた2次元図形の重心を計算します。これがコンタクトポイントになります。

これでOBBとOBBの衝突判定は完成です。

### 1.14 コライダーにOBBとOBBの衝突判定を追加する

最後に、作成したOBBとOBBの衝突判定を、コライダークラスから使えるようにします。`Collider.cpp`を開き、`Intersect`関数の定義を次のように変更してください。

```diff
     }, {
       Func<BoxCollider, SphereCollider>,
       NotCollide,
-      NotCollide,
+      Func<BoxCollider, BoxCollider>,
     },
   };
```

プログラムが書けたらビルドして実行してください。OBBとOBBが、直方体の面にそって衝突するようになっていたら成功です。

### 1.15 OBBとAABBの衝突判定を定義する

OBBとAABB、及びAABBとOBBの衝突判定は、AABBをOBBに変換することで行います。`Collision.h`を開き、次の関数宣言を追加してください。

```diff
 bool Intersect(const Sphere& sphere, const Box& box, ContactPoint& cp);
 bool Intersect(const Box& box, const Sphere& sphere, ContactPoint& cp);
 bool Intersect(const Box& boxA, const Box& boxB, ContactPoint& cp);
+bool Intersect(const Box& box, const AABB& aabb, ContactPoint& cp);
+bool Intersect(const AABB& aabb, const Box& box, ContactPoint& cp);

 } // namespace Collision
```

```diff
   cp.position /= static_cast<float>(c0.size());
   return true; // 衝突している
 }
+
+/**
+* OBBとAABBの衝突判定
+*
+* @param box  衝突判定を行うOBB
+* @param aabb 衝突判定を行うAABB
+* @param cp   衝突結果を格納するコンタクトポイント
+*
+* @retval true  衝突している
+* @retval false 衝突していない
+*/
+bool Intersect(const Box& box, const AABB& aabb, ContactPoint& cp)
+{
+  Box boxB;
+  boxB.p = (aabb.min + aabb.max) * 0.5f;
+  boxB.scale = (aabb.max - aabb.min) * 0.5f;
+  return Intersect(box, boxB, cp);
+}

 } // namespace Collision
```

<pre class="tnmai_assignment">
<strong>【課題01】</strong>
AABBとOBBの衝突判定を行う<code>Intersect</code>関数を定義しなさい。
</pre>

<pre class="tnmai_assignment">
<strong>【課題02】</strong>
<code>Collider.cpp</code>の<code>Intersect</code>関数にある関数テーブルに、AABBとOBB及びOOBBとAABBの衝突判定を行う関数を追加しなさい。
</pre>

<pre class="tnmai_assignment">
<strong>【課題03】</strong>
AABBコライダーを持つ直方体オブジェクトを追加し、OBBとAABBの衝突判定が正しく動作していることを確認しなさい。
</pre>

>**【1章のまとめ】**
>
>* 
>* 
>* 

<div style="page-break-after: always"></div>

## 2. カプセルの衝突判定

### 2.1 カプセル構造体を定義する

この章では、「カプセル」の衝突判定を作成します。カプセルは球体と比べると衝突判定が複雑です。しかし、ゲーム中に登場するオブジェクトには細長いものも多く、そのような形状には球体よりカプセルが適しています。

さっそく、「カプセルを表す構造体」を定義しましょう。カプセルは「中心の線分」と「半径」によって定義されます。`Collision.h`を開き、`Box`構造体の定義の下に、次のプログラムを追加してください。
```diff
   VecMath::vec3 axis[3] = { { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 } };
   VecMath::vec3 scale = { 1, 1, 1 };
 };
+
+/**
+* カプセル
+*/
+struct Capsule
+{
+  LineSegment seg; // 中心の線分
+  float radius;    // 半径
+};

 /**
 * 衝突情報を保持する構造体
```

### 2.2 カプセルの最近接点を求める関数を定義する

カプセルの衝突判定を行うために、「カプセルの中心線分に対する最近接点を求める関数」を定義します。OBBと点の最近接点を求める`ClosestPoint`関数の宣言の下に、次のプログラムを追加してください。

```diff
 };

 VecMath::vec3 ClosestPoint(const AABB& aabb, const VecMath::vec3& p);
 VecMath::vec3 ClosestPoint(const Box& box, const VecMath::vec3& p);
+VecMath::vec3 ClosestPoint(const LineSegment& seg, const VecMath::vec3& p);
+LineSegment ClosestPoint(const LineSegment& segA, const LineSegment& segB);

 bool Intersect(const Sphere& s0, const Sphere& s1, ContactPoint& cp);
 bool Intersect(const AABB& a, const AABB& b, ContactPoint& cp);
```

ここでは2つの関数を宣言しています。線分と点の最近接点は、カプセルと球の衝突判定で使います。線分同士の最近接点は、カプセル同士の衝突判定で使います。

線分と点の最近接点を計算するほうから定義していきましょう。線分と点の最近接点は、点を線分に射影することで求められます。

`Collision.cpp`を開き、OBBと点の最近接点を求める`ClosestPoint`関数の定義の下に、次のプログラムを追加してください。

```diff
   }
   return p;
 }
+
+/**
+* 線分上の最近接点を求める
+*
+* @param seg   最近接点を求める線分
+* @param point 最近接点を求める座標
+*
+* @return pointからsegへの最近接点
+*/
+vec3 ClosestPoint(const LineSegment& seg, const vec3& point)
+{
+  // 点を線分に射影
+  const vec3 d = seg.end - seg.start;
+  const float t = dot(point - seg.start, d);
+
+  // 線分の範囲に制限
+  if (t <= 0) {
+    return seg.start;
+  }
+  const float d2 = dot(d, d); // 線分の長さの2乗
+  if (t >= d2) {
+    return seg.end;
+  }
+
+  // 最近接点を計算して返す
+  return seg.start + d * (t / d2);
+}

 /**
 * 球体と球体の衝突判定
```

線分の始点をA, 終点をBとすると、線分AB上の点Cは、媒介変数`t`を用いて次のように表現できます。

&emsp;`C(t) = A + t(B - A)`

任意の点Pを線分ABに射影したとき、射影点を表す媒介変数`t`は次のように表されます。

&emsp;`t = dot(P - A, normalize(B - A)) / length(B - A)`&emsp;...(1)

ただし、この式は`normalize`と`length`という時間のかかる関数を含むため、あまり使われません。そこで、式を変形します。線分ABの長さを`L`とすると、式(1)は次のようになります。

&emsp;`t = dot(P - A, (B - A) / L) / L`&emsp;...(2)

ベクトルの内積の性質のひとつに、「右辺または左辺にかかる倍数は、内積の外に出すことができる」というものがあります。この性質を利用すると、式(2)を次のように変形できます。

&emsp;`t = dot(P - A, B - A) / (L * L)`&emsp;...(3)

Lは「線分ABの長さ」なので、L*Lは「線分ABの長さの2乗」です。「長さの2乗」は内積によって計算できるため、式(3)は次のように変形できます。

&emsp;`t = dot(P - A, B - A) / dot(B - A, B - A)`&emsp;...(4)

このように、式を変形することで、時間のかかる`normalize`と`length`を、より高速な内積と除算のペアに置き換えることができます。

直線と点の場合はこれで終わりです。しかし、線分の場合は`t`の範囲を線分上に制限する処理が追加されます。

上記のプログラムでは、範囲を制限する処理に式(4)の分母の計算を組み込んでいます。これによって、最近接点が線分の端にある場合は不要な計算を行わないようにしています。

### 2.3 線分同士の最近接点を求める関数を定義する

続いて、線分同士の最近接点を求める関数を定義します。線分と点の最近接点を求める`ClosestPoint`関数の定義の下に、次のプログラムを追加してください。

```diff
   // 最近接点を計算して返す
   return seg.start + d * t;
 }
+
+/**
+* 2つの線分の最近接点を求める
+*
+* @param segA  最近接点を求める線分その1
+* @param segB  最近接点を求める線分その2
+* @param denom segA上の最近接点の比率
+*
+* @return segA上の最近接点とsegB上の最近接点
+*/
+LineSegment ClosestPoint(const LineSegment& segA, const LineSegment& segB)
+{
+}

 /**
 * 球体と球体の衝突判定
```

線分同士の場合、最近接点は各線分にひとつずつ存在するため、関数の戻り値は2つの最近接点を結ぶ線分とします。

2つの線分をL0, L1とし、媒介変数`s`と`t`を用いて以下の式で表すとします。p0, p1は各線分の始点、d0, d1は各線分のベクトル、s, tは任意の実数です。

&emsp;`L0(s) = p0 + d0 * s`<br>
&emsp;`L1(t) = p1 + d1 * t`

線分と点の最近接点の場合と同様に、最初はsとtの範囲を制限せずに最近接点を求め、そのあとで線分の範囲に制限する、という手順で計算します。

2つの最近接点を結ぶ直線をV(s,t)とし、以下のように定義します。

&emsp;`V(s, t) = L0(s) - L1(t)`

Vの長さが最小のとき、sとtは最近接点を示します。Vの長さが最小になるのは、VがL0, L1の両方に垂直なときです。

2直線が垂直かどうかは、2直線の内積が0かどうかで判別できます。つまり、以下の式を満たすsとtの値を見つける必要がある、ということです。

&emsp;`dot(d0, V(s, t)) = 0`&emsp;&emsp;...(1)<br>
&emsp;`dot(d1, V(s, t)) = 0`&emsp;&emsp;...(2)

ここまでに登場した式を使って式(1)を展開すると、次の式(3)が得られます。

&emsp;`dot(d0, L0(s) - L1(t))`<br>
&emsp;→`dot(d0, ((p0+d0*s) - (p1+d1*t))`<br>
&emsp;→`dot(d0, p0-p1 + d0*s - d1*t)`&emsp;&emsp;...(3)

さらに、内積の分配法則と結合法則を利用して式を3つの内積に展開します。

&emsp;`dot(d0, p0-p1) + dot(d0, d0)*s - dot(d0, d1)*t = 0`

媒介変数s, tを持たない成分を右辺に移動し、さらに式(2)も同様に展開します。すると、以下の2つの式が得られます。

&emsp;`dot(d0, d0)*s - dot(d0, d1)*t = -dot(d0, p0-p1)`&emsp;...(4): 式(1)を展開した式<br>
&emsp;`dot(d1, d0)*s - dot(d1, d1)*t = -dot(d1, p0-p1)`&emsp;...(5): 式(2)を展開した式

見やすいように、内積を次のように記号で置き換えます。

&emsp;`a = dot(d0, d0)`<br>
&emsp;`b = dot(d0, d1)`<br>
&emsp;`c = dot(d0, p0-p1)`<br>
&emsp;`e = dot(d1, d1)`<br>
&emsp;`f = dot(d1, p0-p1)`

すると、式(4)と式(5)は次のように表せます。

&emsp;`a*s - b*t = -c`&emsp;...(6)<br>
&emsp;`b*s - e*t = -f`&emsp;...(7)

この連立方程式をsとtについて解くことで、最近接点を求めることができます。

&emsp;`s = (b*f - c*e) / (a*e - b*b)`<br>
&emsp;`t = (a*f - b*c) / (a*e - b*b)`

それでは、`ClosestPoint`関数の中身を書いていきましょう。まずベクトルと内積を計算します。線分同士の`ClosestPoint`関数の定義に次のプログラムを追加してください。

```diff
 LineSegment ClosestPoint(const LineSegment& segA, const LineSegment& segB)
 {
+  const vec3 d0 = segA.end - segA.start; // 線分Aの方向ベクトル
+  const vec3 d1 = segB.end - segB.start; // 線分Bの方向ベクトル
+  const vec3 r = segA.start - segB.start;
+  const float a = dot(d0, d0); // 線分Aの長さの2乗
+  const float b = dot(d0, d1);
+  const float c = dot(d0, r);
+  const float e = dot(d1, d1); // 線分Bの長さの2乗
+  const float f = dot(d1, r);
 }

 /**
 * 球体と球体の衝突判定
```

直線の長さは無限ですが、線分の長さは有限です。そのため、非常に短い線分についても考慮しなくてはなりません。非常に短い線分は「点」として扱うことができます。

ベクトルと内積を計算するプログラムの下に、次のプログラムを追加してください。

```diff
   const float c = dot(d0, r);
   const float e = dot(d1, d1); // 線分Bの長さの2乗
   const float f = dot(d1, r);
+
+  // 線分の長さが0という特殊ケースを処理する
+  // 長さが0の線分を「点」とみなして計算
+
+  // 線分AとBの両方の長さが0
+  if (a < 0.0001f && e < 0.0001f) {
+    return { segA.start, segB.start };
+  }
+
+  // 線分Aの長さが0
+  if (a < 0.0001f) {
+    if (f <= 0) {
+      return { segA.start, segB.start };
+    } else if (f >= e) {
+      return { segA.start, segB.end };
+    }
+    return { segA.start, segB.start + d1 * (f / e) };
+  }
+
+  // 線分Bの長さが0
+  if (e < 0.0001f) {
+    if (-c <= 0) {
+      return { segA.start, segB.start };
+    } else if (-c >= a) {
+      return { segA.end, segB.start };
+    }
+    return { segA.start + d0 * (-c / a), segB.start };
+  }
 }

 /**
 * 球体と球体の衝突判定
```

線分が十分に長い場合、次は線分が平行かどうかをチェックします。線分が平行でない場合、一般的な最近接点の計算を行います。線分の長さが0の場合を処理するプログラムの下に、次のプログラムを追加してください。

```diff
     }
     return { segA.start + d0 * (-c / a), segB.start };
   }
+
+  // 線分の長さが0より大きいと分かったら、線分が平行かどうかをチェックする
+  // 線分が平行な場合、sを求める式の分母が0になり計算できないため
+  const float denom = a * e - b * b;
+  if (denom) {
+    // 線分Aの最近接点を求め、線分Aの範囲に制限
+    float s = std::clamp((f * b - c * e) / denom, 0.0f, 1.0f);
+
+    // 線分Bの最近接点を求める
+    float t = b * s + f;
+
+    // tが線分Bの外側を指している場合
+    // tを線分Bの端点に設定し、sを計算しなおす
+    LineSegment result;
+    if (t < 0) {
+      result.end = segB.start;
+      s = std::clamp(-c / a, 0.0f, 1.0f);
+    } else if (t > e) {
+      result.end = segB.end;
+      s = std::clamp((b - c) / a, 0.0f, 1.0f);
+    } else {
+      result.end = segB.start + d1 * (t / e);
+    }
+    result.start = segA.start + d0 * s;
+    return result;
+  }
 }

 /**
 * 球体と球体の衝突判定
```

正しい最近接点を得るには、sとtを一度だけ範囲制限するだけでは足りないことに注意してください。まず範囲制限したsを計算し、次にsを元にtを計算したあと、tの値によってsに対してもう一度範囲制限を行わなくてはなりません。

最後に、線分が平行だった場合の処理を追加します。線分が平行な場合、最近接点を結ぶ直線は無数に存在する可能性があります。

最近接点としては、どの直線を選んでも正解です。しかし、今回は最近接点をコンタクトポイントとして利用したいので、適当に選ぶわけにはいきません。

基本的に、コンタクトポイントには衝突範囲の中心が選ばれます。そこで、今回のケースでも「線分の重複する範囲の中点」を選択することにします。

線分の重複する範囲を求めるには、線分Bの両端を線分Aに射影し、次に射影した座標を線分Aの範囲に制限します。そして、範囲制限後の2つの座標の中点を最近接点とします。

それでは、線分が平行でない場合のプログラムの下に、次のプログラムを追加してください。

```diff
     result.start = segA.start + d0 * s;
     return result;
   }
+
+  // 線分が平行な場合、線分の重複する範囲の中点を選択
+
+  // 線分Bを線分Aに射影
+  float u = dot(d0, segB.start - segA.start);
+  float v = dot(d0, segB.end - segA.start);
+
+  // 射影した座標を線分Aの範囲に制限
+  u = std::clamp(u, 0.0f, a);
+  v = std::clamp(v, 0.0f, a);
+
+  // uとvの中点が線分Aの最近接点になる
+  s = (u + v) / a * 0.5f;
+  LineSegment result;
+  result.start = segA.start + d0 * s;
+
+  // 線分Aの最近接点を線分Bに射影
+  const float t = dot(d1, result.start - segB.start);
+
+  // 射影した座標を線分Bの範囲に制限
+  if (t <= 0) {
+    result.end = segB.start;
+  } else if (t >= e) {
+    result.end = segB.end;
+  } else {
+    result.end = segB.start + d1 * (t / e);
+  }
+
+  return result;
 }

 /**
 * 球体と球体の衝突判定
```

これで、線分同士の最近接点を求める関数は完成です。

### 2.4 球体とカプセルの衝突判定を定義する

作成した最近接点を求める関数を使って、「球体とカプセルの衝突判定を行う関数」を作成します。`Collision.h`を開き、AABBとOBBの`Intersect`関数宣言の下に、次のプログラムを追加してください。

```diff
 bool Intersect(const Box& boxA, const Box& boxB, ContactPoint& cp);
 bool Intersect(const Box& box, const AABB& aabb, ContactPoint& cp);
 bool Intersect(const AABB& aabb, const Box& box, ContactPoint& cp);
+bool Intersect(const Sphere& sphere, const Capsule& capsule, ContactPoint& cp);
+bool Intersect(const Capsule& capsule, const Sphere& sphere, ContactPoint& cp);

 } // namespace Collision
```

次に`Collision.cpp`を開き、OBBと球体の`Intersect`関数の定義の下に、次のプログラムを追加してください。

```diff
   boxA.scale = (aabb.max - aabb.min) * 0.5f;
   return Intersect(boxA, box, cp);
 }
+
+/**
+* 球体とカプセルの衝突判定
+*
+* @param sphere  衝突判定を行う球体
+* @param capsule 衝突判定を行うカプセル
+* @param cp      衝突結果を格納するコンタクトポイント
+*
+* @retval true  衝突している
+* @retval false 衝突していない
+*/
+bool Intersect(const Sphere& sphere, const Capsule& capsule, ContactPoint& cp)
+{
+  const vec3 p = ClosestPoint(capsule.seg, sphere.p);
+  return Intersect(sphere, Sphere{ p, capsule.radius }, cp);
+}

 } // namespace Collision
```

球体とカプセルの衝突判定は、カプセルの線分に対する最近接点を求めたあと、最近接点を中心とする球体との衝突判定を行うだけです。

同様に、「カプセルと球体の衝突判定を行う関数」も定義しましょう。球体とカプセルの衝突判定を行う`Intersect`関数の定義の下に、次のプログラムを追加してください。

```diff
   const vec3 p = ClosestPoint(capsule.seg, sphere.p);
   return Intersect(sphere, Sphere{ p, capsule.radius }, cp);
 }
+
+/**
+* カプセルと球体の衝突判定
+*
+* @param capsule 衝突判定を行うカプセル
+* @param sphere  衝突判定を行う球体
+* @param cp      衝突結果を格納するコンタクトポイント
+*
+* @retval true  衝突している
+* @retval false 衝突していない
+*/
+bool Intersect(const Capsule& capsule, const Sphere& sphere, ContactPoint& cp)
+{
+  const vec3 p = ClosestPoint(capsule.seg, sphere.p);
+  return Intersect(Sphere{ p, capsule.radius }, sphere, cp);
+}

 } // namespace Collision
```

球体とカプセルの衝突判定との違いは、球体同士の`Intersect`関数に渡す引数の順序が逆になっていることです。

<pre class="tnmai_assignment">
<strong>【課題04】</strong>
<code>Collider.cpp</code>の<code>Intersect</code>関数にある関数テーブルに、「球体とカプセル」および「カプセルと球体」の衝突判定を行う関数を追加しなさい。
プログラムを実行して、球体とカプセルの衝突判定が正しく動作することを確認しなさい。
</pre>

### 2.5 カプセル同士の衝突判定を定義する

続いて、「カプセル同士の衝突判定を行う関数」を作成します。`Collision.h`を開き、AABBとOBBの`Intersect`関数宣言の下に、次のプログラムを追加してください。

```diff
 bool Intersect(const AABB& aabb, const Box& box, ContactPoint& cp);
 bool Intersect(const Sphere& sphere, const Capsule& capsule, ContactPoint& cp);
 bool Intersect(const Capsule& capsule, const Sphere& sphere, ContactPoint& cp);
+bool Intersect(const Capsule& capA, const Capsule& capB, ContactPoint& cp);

 } // namespace Collision
```

カプセル同士の場合も「最近接点を中心とする球体」を仮定し、球体同士の衝突判定を行います。ただし、カプセルの線分が実際に交差している場合、線分の情報を使って衝突方向を計算できる可能性があります。

とりあえず、球体同士の衝突として扱える場合の衝突判定から書いていきましょう。`Collision.cpp`を開き、カプセルと球体の`Intersect`関数の定義の下に、次のプログラムを追加してください。

```diff
   const vec3 p = ClosestPoint(capsule.seg, sphere.p);
   return Intersect(Sphere{ p, capsule.radius }, sphere, cp);
 }
+
+/**
+* カプセルとカプセルの衝突判定
+*
+* @param capA  衝突判定を行うカプセルその1
+* @param capB  衝突判定を行うカプセルその2
+* @param cp    衝突結果を格納するコンタクトポイント
+*
+* @retval true  衝突している
+* @retval false 衝突していない
+*/
+bool Intersect(const Capsule& capA, const Capsule& capB, ContactPoint& cp)
+{
+  const LineSegment seg = ClosestPoint(capA.seg, capB.seg);
+  const vec3 d = seg.start - seg.end;
+  const float d2 = dot(d, d);
+  const float totalRadius = capA.radius + capB.radius;
+  if (d2 > totalRadius * totalRadius) {
+    return false;
+  }
+
+  // 最近接点同士の距離が0より大きい場合
+  // 球体同士と同じ方法でコンタクトポイントを計算する
+  if (d2 >= 0.00001f) {
+    const float distance = std::sqrt(d2);
+    cp.normal = d * (1.0f / distance);
+    cp.penetration = distance - totalRadius;
+    cp.position = seg.start - cp.normal * (capA.radius - cp.penetration * 0.5f);
+    return true;
+  }
+
+  // 最近接点同士の距離が0の場合
+
+  return true;
+}

 } // namespace Collision
```

続いて、「線分が重なっている(変数`seg`の長さが0)場合」を扱うプログラムを追加しましょう。`ClosestPoint`関数から返された最近接点同士の距離が0の場合、最近接点から法線を計算することができません。

しかし、カプセル同士の場合は、カプセルの線分から法線を生成できる可能性があります。「最近接点同士の距離が0の場合」というコメントの下に、次のプログラムを追加してください。

```diff
     return true;
   }

   // 最近接点同士の距離が0の場合
+  // segから法線を計算できないので、2軸に垂直な方向を衝突法線とする
+  const vec3 d0 = capA.seg.end - capA.seg.start;
+  const vec3 d1 = capB.seg.end - capB.seg.start;
+  cp.normal = cross(d0, d1);
+  if (dot(cp.normal, cp.normal) < 0.00001f) {
+    // 外積によって得た法線ベクトルの長さが0の場合、2軸は平行
+    // 法線ベクトルを作れないので、d0ベクトルに垂直な方向を衝突法線とする
+    if (d0.x) {
+      cp.normal = { -(d0.y + d0.z) / d0.x, 1, 1 };
+    } else if (d0.y) {
+      cp.normal = { 1, -(d0.x + d0.z) / d0.y, 1 };
+    } else {
+      cp.normal = { 1, 1, -(d0.x + d0.y) / d0.z };
+    }
+  }
+  cp.normal = normalize(cp.normal);
+
+  // 大きい方の半径を貫通距離とする
+  cp.penetration = -std::max(capA.radius, capB.radius);
+
+  // コンタクトポイントの座標を計算
+  cp.position = seg.start - cp.normal * (capA.radius - cp.penetration * 0.5f);
+
   return true;
 }
```

最近接点同士の距離が0の場合、2つのカプセルの線分に垂直な方向を衝突法線とします。これは正しい衝突方向ではないかもしれませんが、ほとんどのケースでは大きく外れた方向にはならないと考えられます。

それから、カプセルの線分が平行になっている場合も考慮する必要があります。この場合、「どちらかの線分に対して垂直な方向」を衝突法線とします。

衝突法線をNとすると、Nは線分ベクトル`d0`に対して垂直なので、内積を使った以下の式が成り立ちます。

&emsp;`dot(d0, N) = 0`<br>
&emsp;→`d0.x * N.x + d0.y * N.y + d0.z * N.z = 0`&emsp;...(1)

式(1)を`N.x`について解くと、

&emsp;`N.x = -(d0.y * N.y + d0.z * N.z) / d0.x`

となります。今回のケースでは、垂直であれば方向は問わないので、例えば`N.y = 1`, `N.z = 1`を代入します。すると、

&emsp;`N.x = -(d0.y + d0.z) / d0.x`

という式が得られます。これが上記のプログラムで行っている計算です。

ですが、なぜ線分に対して垂直な方向を選ぶのでしょうか？

球体同士の衝突では、重なっている場合は常に上向きの衝突法線を設定していました。理由は、球体の場合はどの方向から衝突したかを推し量る手がかりが無かったからです。

球体と比較すると、カプセルは線分方向に長い形状をしています。そのため、面積の広い側面から衝突する可能性が高くなると予想できます。

当然、この予想が常に当たるわけではありませんが、多くの場合に妥当な方向であるとはいえるでしょう。これが、「線分が平行な場合は、線分と直角な方向を衝突法線とする」というプログラムの根拠です。

<pre class="tnmai_assignment">
<strong>【課題05】</strong>
<code>Collider.cpp</code>の<code>Intersect</code>関数にある関数テーブルに「カプセルとカプセル」の衝突判定を行う関数を追加しなさい。
プログラムを実行して、カプセルとカプセルの衝突判定が正しく動作することを確認しなさい。
</pre>

### 2.6 カプセルとOBBの交差範囲を求める関数を定義する

ここからは「カプセルとOBBの衝突判定」を作成します。カプセルとOBBの衝突判定には「分離軸判定」を使います。基本的な流れは「OBBとOBBの衝突判定」と同じです。

ただし、OBB用に作成した関数は使えません。そこで、カプセルに対応した新しい関数を作成します。

>* カプセルとOBBを分離軸に射影し、交差範囲を求める`GetIntersectionLength`(ゲット・インターセクション・レングス)関数
>* OBBの面と線分との最近接点を求める`ClosestPoint`(クローゼスト・ポイント)関数

それでは、`GetIntersectionLength`関数から作成していきましょう。`Collision.cpp`を開き、OBB用の`GetIntersectionLenght`関数の定義の下に、次のプログラムを追加してください。

```diff
   float length = max - min;
   return length - lenA - lenB;
 }
+
+/**
+* カプセルとOBBを軸ベクトルに射影し、交差している範囲を求める
+*
+* @param capsule    カプセル
+* @param verticesB  OBBの頂点配列
+* @param axis       射影先の軸ベクトル
+* @param shouldFlip 衝突法線の反転の有無
+* @param minIndex   射影範囲の最小値に対応する頂点配列インデックス
+* @param maxIndex   射影範囲の最大値に対応する頂点配列インデックス
+*
+* @return 交差している距離(計算の都合でマイナス値になっていることに注意)
+*/
+float GetIntersectionLength(const Capsule& capsule, const vec3* verticesB,
+  const vec3& axis, bool& shouldFlip,
+  int& minIndex, int& maxIndex)
+{
+}

 /**
 * 点がOBB内にあるかどうかを調べる
```

OBB同士の`GetIntersectionLength`に対して、`minIndex`と`maxIndex`という2つの引数を追加しています。これらの引数は、コンタクトポイントを計算するために追加しています。コンタクトポイントを求めない場合は不要です。

まず、カプセルを軸ベクトルに射影します。`GetIntersectionLength`関数の定義に次のプログラムを追加してください。

```diff
   const vec3& axis, bool& shouldFlip,
   int& minIndex, int& maxIndex)
 {
+  // カプセルを軸に射影
+  float minA, maxA;
+  minA = maxA = dot(axis, capsule.seg.start);
+  float f = dot(axis, capsule.seg.end);
+  minA = std::min(minA, f) - capsule.radius;
+  maxA = std::max(maxA, f) + capsule.radius;
 }

 /**
 * 点がOBB内にあるかどうかを調べる
```

このプログラムは、内積によってカプセルの始点と終点を軸ベクトルに射影し、小さい方の数値を`minA`(ミン・エー)に、大きい方の数値を`maxA`(マックス・エー)に代入します。

カプセルは「半径」を持っているため、射影した値を半径サイズだけ増減させる必要があることに注意してください。

次にOBBを軸ベクトルに射影します。ここではOBBを射影する`ProjectBoxToAxis`関数は使えません。なぜなら、今回は「最小値と最大値の頂点インデックスを記録」しなくてはならないからです。

そこで、`ProjectBoxToAxis`関数の内容をコピーして、そこに「頂点インデックスを記録する機能」を追加することにします。カプセルを軸に射影するプログラムの下に、次のプログラムを追加してください。

```diff
   float f = dot(axis, capsule.seg.end);
   minA = std::min(minA, f) - capsule.radius;
   maxA = std::max(maxA, f) + capsule.radius;
+
+  // OBBを軸に射影
+  minIndex = maxIndex = 0;
+  float minB, maxB;
+  minB = maxB = dot(axis, verticesB[0]);
+  for (int i = 1; i < 8; ++i) {
+    float f = dot(axis, verticesB[i]);
+    if (f < minB) {
+      minB = f;
+      minIndex = i; // 最小値のインデックスを記録
+    }
+    if (f > maxB) {
+      maxB = f;
+      maxIndex = i; // 最大値のインデックスを記録
+    }
+  } // for
 }

 /**
 * 点がOBB内にあるかどうかを調べる
```

これで、軸ベクトルに射影したカプセルとOBBの範囲が計算できました。最後に、交差判定を行い、交差していたら交差範囲の長さを計算して返しましょう。OBBを射影するプログラムの下に、次のプログラムを追加してください。

```diff
       maxIndex = i; // 最大値のインデックスを記録
     }
   } // for
+
+  // 距離が0以上なら分離超平面を入れる隙間がある(つまり交差していない)
+  if (minB > maxA && minA > maxB) {
+    return false;
+  }
+
+  // 衝突法線は「OBBその1」が左、「OBBその2」が右にあると想定しているので、
+  // 順序が逆になっている場合、衝突法施の向きを反転する必要がある、
+  // ということを、呼び出し元に伝える
+  shouldFlip = minB < minA;
+
+  // 交差している距離を計算
+  float lenA = maxA - minA;
+  float lenB = maxB - minB;
+  float min = std::min(minA, minB);
+  float max = std::max(maxA, maxB);
+  float length = max - min;
+  return length - lenA - lenB;
 }

 /**
 * 点がOBB内にあるかどうかを調べる
```

これでカプセルとOBBの交差範囲を求める`GetIntersectionLength`関数は完成です。

### 2.7 三次元空間の長方形を定義する

次に、OBBの面とカプセルの線分について、最近接点を求める関数を定義します。まず「面」を表す構造体を定義しましょう。`Collision.h`を開き、`Plane`構造体の定義の下に、次のプログラムを追加してください。

```diff
   VecMath::vec3 normal; // 面の法線
   float d; // 原点からの距離
 };
+
+/**
+* 3D長方形
+*/
+struct Rectangle
+{
+  VecMath::vec3 center;  // 長方形の中心座標
+  VecMath::vec3 normal;  // 面の法線
+  VecMath::vec3 axis[2]; // 長方形の軸
+  float scale[2];        // 軸方向の大きさ
+};

 /**
 * 軸平行境界ボックス
```

3次元空間の長方形は、OBBの任意の軸の大きさがゼロになったものと考えられます。なお、面法線は必須ではありません。2つの軸の外積によって計算できるからです。しかし、今回は外積を避けるために、あえて面法線を追加することにしました。

### 2.8 3D長方形と線分の最近接点を求める関数を定義する

それでは、3D長方形と線分の最近接点を求める`ClosestPoint`関数を作成しましょう。まず、関数宣言を追加します。`Collision.h`を開き、線分同士の`ClosestPoint`関数の宣言の下に、次のプログラムを追加してください。

```diff
 VecMath::vec3 ClosestPoint(const Box& box, const VecMath::vec3& p);
 VecMath::vec3 ClosestPoint(const LineSegment& seg, const VecMath::vec3& p);
 LineSegment ClosestPoint(const LineSegment& segA, const LineSegment& segB);
+LineSegment ClosestPoint(const Rectangle& rect, const LineSegment& seg);

 bool Intersect(const Sphere& s0, const Sphere& s1, ContactPoint& cp);
 bool Intersect(const AABB& a, const AABB& b, ContactPoint& cp);
```

次に`Collision.cpp`を開き、線分同士の`ClosestPoint`関数の定義の下に、次のプログラムを追加してください。

```diff
   }
   return result;
 }
+
+/**
+* 3D長方形と線分の最近接点を求める
+*
+* @param rect 最近接点を求める3D長方形
+* @param seg  最近接点を求める線分
+*
+* @return seg上の最近接点とrect上の最近接点
+*/
+LineSegment ClosestPoint(const Rectangle& rect, const LineSegment& seg)
+{
+}

 /**
 * 球体と球体の衝突判定
```

長方形と線分の最近接点は、以下の7つの最近接点リストのうち「最近接点間の距離が最も短いもの」になります。

>1: 長方形と線分の交点(長方形と線分が交差していない場合は除外)<br>
>2: 長方形の面と線分の始点の最近接点(ただし、最近接点が長方形の範囲外にある場合は除外)<br>
>3: 長方形の面と線分の終点の最近接点(ただし、最近接点が長方形の範囲外にある場合は除外)<br>
>4,5,6,7: 長方形の4つの辺と線分の最近接点<br>
>例外: 長方形と線分が平行で、長方形の上から見て線分が交差している場合の最近接点<br>

リストの最後にある「例外」は、長方形と線分が平行な場合に、最近接点が無限に存在する可能性があることを考慮したものです。

互いに平行な場合は、線分上のどの座標を取っても最近接点になります。しかし、コンタクトポイントとして使うためには、あまり適当な座標を選ぶわけにはいきません。

そこで今回は、「交差範囲の中心」を最近接点として選びました。一般に、衝突が複数の点または範囲で起きた場合、その範囲の平均をコンタクトポイントとすると、現実的にそれらしい結果になることが多いのです。

>別の解決策として、複数のコンタクトポイントを生成する方法もあります。

さて、上記のリストをひとつずつやっつけていくわけですが、まずは例外である「長方形と線分が平行な場合」を処理します。このケースを先に処理することで、あとのプログラムでは「平行でないことを前提にできる」からです。

それでは、長方形と線分の`ClosestPoint`関数の定義に、次のプログラムを追加してください。

```diff
 */
 LineSegment ClosestPoint(const Rectangle& rect, const LineSegment& seg)
 {
+  // 線分の始点を面に射影
+  const vec3 ca = seg.start - rect.center;
+  const float a0 = dot(ca, rect.axis[0]);
+  const float a1 = dot(ca, rect.axis[1]);
+
+  // 長方形と線分の平行性を調べる
+  const vec3 ab = seg.end - seg.start;
+  const float n = dot(rect.normal, ab);
+  if (abs(n) <= 0.0001f) {
+    // 平行な場合、線分が長方形の上に乗っているかどうかを調べる
+    float tmin = -FLT_MAX;
+    float tmax = FLT_MAX;
+    const float list[] = { a0, a1 };
+    for (int i = 0; i < 2; ++i) {
+      // 線分とaxis[i]との平行性を調べる
+      const float d = dot(ab, rect.axis[i]);
+      if (abs(d) <= 0.0001f) {
+        continue; // 平行なので交点がない
+      }
+      // 長方形中心からの距離を線分の比率として表す
+      float t0 = (-rect.scale[i] - list[i]) / d;
+      float t1 = (rect.scale[i] - list[i]) / d;
+      if (t0 > t1) {
+        std::swap(t0, t1);
+      }
+      // 長方形と交差している範囲を計算
+      tmin = std::max(t0, tmin);
+      tmax = std::min(t1, tmax);
+    }
+
+    // 線分の始点と終点の範囲に制限する
+    tmin = std::max(0.0f, tmin);
+    tmax = std::min(1.0f, tmax);
+
+    // 線分が長方形に重なっている場合
+    // 重複範囲の中心を最近接点とする
+    if (tmin <= tmax) {
+      const vec3 p = seg.start + ab * ((tmin + tmax) * 0.5f);
+      const float d = dot(rect.normal, p - rect.center);
+      return { p, p - rect.normal * d };
+    }
+  } // if (abs(n) <= 0.0001f)
 }

 /**
 * 球体と球体の衝突判定
```

平行性の判定は内積によって行います。平行だと判定されたら最近接点を計算して返します。最近接点は、「長方形を真上から見たとき、長方形と線分が重なっている範囲の中心」になります。

なお、始点の射影結果はあとの処理でも使うため、平行性判定の前に行っています。また、長方形と線分が重なっていない場合、最近接点は「辺と線分の最近接点」となります。

次に、「長方形と線分が交差している場合」を判定します。交差している場合、交点が最近接点になるからです(リストの1)。長方形と線分が平行な場合のプログラムの下に、次のプログラムを追加してください。

```diff
       return { p, p - rect.normal * d };
     }
   } // if (abs(n) <= 0.0001f)
+
+  // 線分が面と交差しているかチェック
+  // 交差している場合、最近接点は交点になる
+  {
+    const float d = dot(rect.normal, rect.center);
+    const float t = (d - dot(rect.normal, seg.start)) / n;
+    if (0 <= t && t <= 1) {
+      // 交点が長方形の範囲内にあるか調べる
+      const vec3 p = seg.start + ab * t;
+      const vec3 v = p - rect.center;
+      const float dist1 = dot(v, rect.axis[0]);
+      if (abs(dist1) <= rect.scale[0]) {
+        const float dist2 = dot(v, rect.axis[1]);
+        if (abs(dist2) <= rect.scale[1]) {
+          return { p, p };
+        }
+      }
+    } // if (0 <= t && t <= n)
+  }
 }

 /**
 * 球体と球体の衝突判定
```

交点を求める場合も、内積による射影が役立ちます。まず、長方形の中心と線分の始点を面法線に対して射影します。この2つの差を求め、線分を射影した長さ`n`で割ると、長方形から線分の始点までの距離`t`が求まります。

線分の長さ`n`で割ることで、`t`は線分に対する比率になります。つまり、`t`が0なら交点は始点にあり、`t`が1なら交点は終点にあり、その間なら交点は線分の途中にあります。そして、`t`が0未満または1より大きい場合は交差していません。

>なお、平行性の判定において`n`が0かどうかは調べているので、ここで0除算が起きることはありえません、

ただし、この計算で求められるのは、長方形が属する無限平面に対する交点に過ぎません。そのため、交点が見つかった場合、長方形の範囲内にあるかどうかを調べなくてはなりません。

交点が長方形の範囲内にあるかどうかは、長方形の中心から交点へ向かうベクトル`v`を、長方形の2つの軸ベクトルに射影することで判定できます。交点が長方形内に有ることが判明したら、その座標を最近接点として返します。

続いて、線分の始点と終点について、長方形との最近接点を求めます(リストの2と3)。線分の交差チェックプログラムの下に、次のプログラムを追加してください。

```diff
       }
     } // if (0 <= t && t <= n)
   }
+
+  // 平行でなく、交差もしていない場合
+
+  // 線分の終点を面に射影
+  const vec3 cb = seg.end - rect.center;
+  const float b0 = dot(cb, rect.axis[0]);
+  const float b1 = dot(cb, rect.axis[1]);
+
+  // 線分の始点および終点の最近接点を求め
+  // 長方形の範囲に含まれる点のうちより近いほうを「仮の最近接点」とする
+  float distance = FLT_MAX;
+  LineSegment result;
+  if (abs(a0) <= rect.scale[0] && abs(a1) <= rect.scale[1]) {
+    distance = dot(rect.normal, ca);
+    distance *= distance; // 比較のために2乗する
+    result = { seg.start, rect.center + rect.axis[0] * a0 + rect.axis[1] * a1 };
+  }
+  if (abs(b0) <= rect.scale[0] && abs(b1) <= rect.scale[1]) {
+    float tmp = dot(rect.normal, cb);
+    tmp *= tmp; // 比較のために2乗する
+    if (tmp < distance) {
+      distance = tmp;
+      result = { seg.end, rect.center + rect.axis[0] * b0 + rect.axis[1] * b1 };
+    }
+  }
 }

 /**
 * 球体と球体の衝突判定
```

ここでも、始点と終点を長方形の軸ベクトルに射影することで最近接点を求めています。ここまでのプログラムと同様に長方形の範囲チェックを行い、範囲外の場合は最近接点候補から外しています。

最後に、リスト4,5,6,7の「辺と線分の最近接点」を求め、仮の最近接点と比較します。終点の最近接点を求めるプログラムの下に、次のプログラムを追加してください。

```diff
       result = { seg.end, rect.center + rect.axis[0] * b0 + rect.axis[1] * b1 };
     }
   }
+
+  // 長方形の4辺について、最近接点を計算
+  const vec3 v1 = rect.axis[0] * rect.scale[0];
+  const vec3 v2 = rect.axis[1] * rect.scale[1];
+  const vec3 v[] = {
+    rect.center + v1 + v2,
+    rect.center + v1 - v2,
+    rect.center - v1 - v2,
+    rect.center - v1 + v2 };
+  for (int i = 0; i < 4; ++i) {
+    const auto s = ClosestPoint(seg, LineSegment{ v[i], v[(i + 1) % 4] });
+    const vec3 ab = s.end - s.start;
+    const float distanceEdge = dot(ab, ab); // 長さの2乗
+    if (distanceEdge < distance) { // 2乗同士の比較
+      distance = distanceEdge;
+      result = s;
+    }
+  }
+  return result;
 }

 /**
 * 球体と球体の衝突判定
```

プログラム自体は単なるforループで、4つの辺に対して以前作成した線分同士の`ClosestPoint`関数を呼び出すだけのものです。これで、「3D長方形と線分の最近接点を求める関数」は完成です。

>**【長方形と線分のClosestPoint関数が、他のClosestPoint関数と比べて複雑な理由】**<br>
>単純な図形の最近接点と比べて、この節で作成したプログラムがかなり複雑に見えると思います。これは、「線分」や「長方形」は単なる直線や平面とは異なり「図形の端がある」ことが原因です。
>図形に端があると、それだけ図形の情報量が増えます。増えた情報量に対処するために、計算が複雑になるのは仕方ありません。

### 2.9 カプセルとOBBの衝突判定関数を定義する

必要な関数を定義したので、ようやくカプセルとOBBの衝突判定を書くことができます。いつものように関数宣言を追加しましょう。`Collision.h`を開き、カプセル同士の`Intersect`関数の宣言の下に、次のプログラムを追加してください。

```diff
 bool Intersect(const Sphere& sphere, const Capsule& capsule, ContactPoint& cp);
 bool Intersect(const Capsule& capsule, const Sphere& sphere, ContactPoint& cp);
 bool Intersect(const Capsule& c0, const Capsule& c1, ContactPoint& cp);
+bool Intersect(const Capsule& capsule, const Box& box, ContactPoint& cp);
+bool Intersect(const Box& box, const Capsule& capsule, ContactPoint& cp);

 } // namespace Collision
```

続いて`Intersect`関数を定義します。`Collision.cpp`を開き、カプセル同士の`Intersect`関数の定義の下に、次のプログラムを追加してください。

```diff
+
+/**
+* カプセルとOBBの衝突判定
+*
+* @param capsule 衝突判定を行うカプセル
+* @param box     衝突判定を行うOBB
+* @param cp      衝突結果を格納するコンタクトポイント
+*
+* @retval true  衝突している
+* @retval false 衝突していない
+*/
+bool Intersect(const Capsule& capsule, const Box& box, ContactPoint& cp)
+{
+  return true;
+}

 } // namespace Collision
```

さて、カプセルとOBBの衝突判定には、OBBとOBBの衝突判定でも利用した「分離軸判定」を使います。分離軸判定には「分離軸に射影する頂点配列」と「分離軸の配列」が必要です。まずこの2つの配列を作成しましょう。

カプセルとOBBの`Intersect`関数の定義に、次のプログラムを追加してください。

```diff
 bool Intersect(const Capsule& capsule, const Box& box, ContactPoint& cp)
 {
+  // OBBの頂点座標配列を取得
+  const std::vector<vec3> verticesA = { capsule.seg.start, capsule.seg.end };
+  const auto verticesB = GetVertices(box);
+
+  // 分離軸判定用の軸ベクトルを計算
+  const vec3 capsuleDirection = capsule.seg.end - capsule.seg.start;
+  const vec3 axis0 = box.axis[0] * box.scale[0];
+  const vec3 axis1 = box.axis[1] * box.scale[1];
+  const vec3 axis2 = box.axis[2] * box.scale[2];
+  const vec3 axisList[] = {
+    box.axis[0], box.axis[1], box.axis[2],           // 0, 1, 2
+    cross(box.axis[0], capsuleDirection),            // 3
+    cross(box.axis[1], capsuleDirection),            // 4
+    cross(box.axis[2], capsuleDirection),            // 5
+    cross(axis0 + axis1 + axis2, capsuleDirection),  // 6
+    cross(axis0 + axis1 - axis2, capsuleDirection),  // 7
+    cross(axis0 - axis1 + axis2, capsuleDirection),  // 8
+    cross(axis0 - axis1 - axis2, capsuleDirection),  // 9
+  };
   return true;
 }
```

OBBとOBBの衝突判定では15個の分離軸が必要でしたが、カプセルはOBBほど複雑ではないため、10個の分離軸があれば十分です。ただし、分離軸とは別に「カプセルの前後の半球」の衝突判定を行う必要があります。

>**【実は7個の分離軸でも判定はできる】**<br>
>衝突の有無を調べるだけなら、OBBの軸は分離軸から除外できます。理由は、辺の外積で作られた分離軸(上記のプログラムでは3,4,5番目の分離軸)がOBBの軸の要素を含むからです。しかし、OBBの軸を分離軸に含めることで、早期に衝突の有無を判定できる可能性が高くなります。また、辺と面の衝突を識別できるため、コンタクトポイントを計算しやすいことも利点です。

それでは、分離軸判定を実装しましょう。分離軸配列を定義するプログラムの下に、次のプログラムを追加してください。

```diff
     cross(axis0 - axis1 + axis2, capsuleDirection),  // 8
     cross(axis0 - axis1 - axis2, capsuleDirection),  // 9
   };
+
+  // 貫通距離を最大にしておく
+  cp.penetration = -FLT_MAX;
+
+  // すべての軸ベクトルに対して分離軸判定を実行
+  int axisIndex = 0; // 衝突した分離軸のインデックス
+  int minIndex = 0, maxIndex = 0;
+  for (int i = 0; i < std::size(axisList); ++i) {
+    // 外積によって作られた軸ベクトルの場合、元の軸が平行だと長さが0になる
+    // この場合、AまたはBの軸による分離軸判定と等しいのでスキップする
+    const float length2 = dot(axisList[i], axisList[i]);
+    if (length2 < 0.0001f) {
+      continue;
+    }
+
+    // 分離軸を正規化
+    const vec3 axis = axisList[i] * (1.0f / sqrt(length2));
+
+    // 交差している距離を計算
+    bool shouldFlip;
+    int tmpMinIndex, tmpMaxIndex;
+    const float d = GetIntersectionLength(capsule, verticesB.data(),
+      axis, shouldFlip, tmpMinIndex, tmpMaxIndex);
+
+    // 距離が0以上なら分離超平面を入れる隙間がある(つまり交差していない)
+    if (d >= 0) {
+      return false;
+    }
+
+    // 貫通距離がより短い方向から衝突したとみなす
+    if (d > cp.penetration) {
+      cp.penetration = d;
+      // 衝突法線は軸ベクトルの逆方向
+      if (shouldFlip) {
+        cp.normal = axis;
+      } else {
+        cp.normal = -axis;
+      }
+      minIndex = tmpMinIndex;
+      maxIndex = tmpMaxIndex;
+      axisIndex = i;
+    }
+  } // for
   return true;
 }
```

分離軸判定については、OBBとOBBの衝突判定とほとんど同じです。OBBとOBBの衝突判定の説明も参考にしてください。

全ての分離軸で衝突していることが分かった場合、さらに半球部分の交差を確認します。これが必要なのは、球体のような形状は無限個の分離軸を持つため、分離軸判定では交差を判定できないからです。

とはいえ、やることは球体と点の衝突判定なので、一方の半径が0の場合の球体と球体の衝突判定と同じです。ただし、実際にはカプセルの両端にある半球の判定なので、最近接点への向きが半球側を向いていることを確認しなくてはなりません。

それから、分離軸判定による貫通距離より短いかどうかも調べる必要があります。分離軸判定のほうが短いのなら、衝突が起きたのは分離軸が先のはずだからです。それでは、分離軸判定プログラムの下に、次のプログラムを追加してください。

```diff
       axisIndex = i;
     }
   } // for
+
+  // 半球部分の交差を確認
+  const float r = capsule.radius + cp.penetration;
+  const vec3 list[] = { capsule.seg.start, capsule.seg.end };
+  for (const auto& e : list) {
+    // OBBの最近接点が半球側にない場合は無視する
+    const vec3 c = ClosestPoint(box, e);
+    const vec3 v = c - e;
+    if (dot(capsuleDirection, v) < 0) {
+      // 最近接点までの距離がカプセルの半径より大きければ衝突していない
+      float t = dot(v, v); // 距離の2乗
+      if (t > capsule.radius * capsule.radius) {
+        return false;
+      }
+      // 最近接点までの距離が分離軸による距離より短い場合のみ半球との衝突を選択
+      if (t > r * r) {
+        t = sqrt(t); // 2乗の状態を解除
+        cp.penetration = t - capsule.radius;
+        cp.normal = -v * (1.0f / t);
+        cp.position = c + cp.normal * (cp.penetration * 0.5f);
+        axisIndex = -1;
+      }
+    }
+  } // for
   return true;
 }
```

これで衝突の有無の判定はできています。衝突が確定したので、コンタクトポイントを生成します。半球との衝突判定プログラムの下に、次のプログラムを追加してください。

```diff
       }
     }
   } // for
+
+  // コンタクトポイントを計算
+  // 分離軸によって場合分け
+  switch (axisIndex) {
+  case 0:
+  case 1:
+  case 2: {
+    // 面で衝突
+    break;
+  }
+  case 3:
+  case 4:
+  case 5: {
+    // 辺で衝突
+    break;
+  }
+  case 6:
+  case 7:
+  case 8:
+  case 9: {
+    // 頂点で衝突
+    break;
+  }
+  } // switch
   return true;
 }
```

OBBとOBBの衝突判定では、分離軸にかかわらず共通のコンタクトポイント生成処理をしていました。それは、OBB同士の交差が複雑であることと、どの方向から見ても似た形状のため、分離軸に関わらずやることが同じだったからです。

しかし、カプセルとOBBの衝突判定では、分離軸によって処理を分けることで効率を上げられます。それでは、「面で衝突」した場合から書いていきましょう。「面で衝突」というコメントの下に、次のプログラムを追加してください。

```diff
   case 1:
   case 2: {
     // 面で衝突
+    // 線分の始点および終点について、面上の最近接点を計算
+    // 最近接点がOBBの範囲内にある場合のみ有効
+    const int axisIndex1 = (axisIndex + 1) % 3;
+    const int axisIndex2 = (axisIndex + 2) % 3;
+    const Rectangle rect = {
+      box.p + cp.normal * box.scale[axisIndex],
+      cp.normal,
+      box.axis[axisIndex1], box.axis[axisIndex2],
+      box.scale[axisIndex1], box.scale[axisIndex2] };
+    const auto seg = ClosestPoint(rect, capsule.seg);
+    cp.normal = normalize(seg.start - seg.end);
+    cp.position = seg.end + cp.normal * (cp.penetration * 0.5f);
     break;
   }
```

面で衝突した場合、まずOBBの面に相当する3D長方形を定義します。そして、3D長方形と線分の最近接点を求め、コンタクトポイントを計算します。

次に、「辺で衝突」した場合を扱います。「辺で衝突」というコメントの下に、次のプログラムを追加してください。

```diff
   case 4:
   case 5: {
     // 辺で衝突
+    //   5----4
+    //  /|   /|
+    // 1----0 |
+    // | 7--|-6
+    // |/   |/
+    // 3----2
+    static const int pairList[][8] = {
+     // 0, 1, 2, 3, 4, 5, 6, 7
+      { 1, 0, 3, 2, 5, 4, 7, 6 },
+      { 2, 3, 0, 1, 6, 7, 4, 5 },
+      { 4, 5, 6, 7, 0, 1, 2, 3 },
+    };
+    int index0 = 0;
+    const float a = dot(cp.normal, capsule.seg.start - verticesB[minIndex]);
+    const float b = dot(cp.normal, capsule.seg.start - verticesB[maxIndex]);
+    if (a < b) {
+      index0 = minIndex;
+    } else {
+      index0 = maxIndex;
+    }
+    const int index1 = pairList[axisIndex - 3][index0];
+    const auto seg = ClosestPoint(capsule.seg,
+      LineSegment{ verticesB[index0], verticesB[index1] });
+    cp.position = seg.end + cp.normal * (cp.penetration * 0.5f);
     break;
   }
```

コメントに書いてある立方体は、その下の`pairList`(ペア・リスト)の数値をわかりやすくするためのものです。

さて、「辺で衝突」した場合ですが、まず射影に使われた2つの頂点は判明しており、それぞれ`minIndex`と`maxIndex`変数として参照できます。

しかし、頂点のインデックスだけでは辺の始点しか分かりません。しかし、「分離軸の元になったOBBの軸」から、辺の方向を予想できます。なぜなら、

>辺の分離軸は外積で作ったので、元になったOBBの軸と直角になっている

からです。例えばX軸から作った辺の分離軸は、X軸と垂直な任意の方向を向きます。そのような分離軸における衝突は、分離軸と垂直な辺で起きていると考えられます。

つまり「X軸から作った任意の分離軸に垂直な辺」は、元のX軸と平行な辺に限られるわけです。`pairList`配列は、分離軸のインデックスと射影に使われた頂点のインデックスから、目的の辺を作り出すための頂点を素早く選択するために使います。

辺の頂点を計算で求めることは可能ですが、数があまり多くない場合は配列を使って対応表を作るほうが効率も高く、コードも読みやすくなります。辺がわかれば、あとは`ClosestPoint`関数で最近接点を求めるだけです。

最後に、「頂点で衝突」した場合を処理しましょう。「頂点で衝突」というコメントの下に、次のプログラムを追加してください。


```diff
   case 8:
   case 9: {
     // 頂点で衝突
+    const float a = dot(cp.normal, capsule.seg.start - verticesB[minIndex]);
+    const float b = dot(cp.normal, capsule.seg.start - verticesB[maxIndex]);
+    if (a < b) {
+      cp.position = verticesB[minIndex] + cp.normal * (cp.penetration * 0.5f);
+    } else {
+      cp.position = verticesB[maxIndex] + cp.normal * (cp.penetration * 0.5f);
+    }
     break;
   }
```

頂点で衝突した場合がもっとも簡単で、頂点と線分の最近接点を求めるだけです。ただし、射影によって選ばれた頂点は`minIndex`と`maxIndex`の2つあるので、どちらか近い方を選ぶ必要があります。

<pre class="tnmai_assignment">
<strong>【課題06】</strong>
OBBとカプセルの衝突判定を行う<code>Intersect</code>関数を追加しなさい。
</pre>

<pre class="tnmai_assignment">
<strong>【課題07】</strong>
<code>Collider.cpp</code>の<code>Intersect</code>関数にある関数テーブルに「カプセルとOBB」および「OBBとカプセル」の衝突判定を行う関数を追加しなさい。
プログラムを実行して、カプセルとOBBの衝突判定が正しく動作することを確認しなさい。
</pre>

<pre class="tnmai_assignment">
<strong>【課題08】</strong>
カプセルとAABBの衝突判定は、AABBをOBBに変換することで実装できます。「カプセルとAABB」および「AABBとカプセル」の衝突判定を行う機能を追加しなさい。
プログラムを実行して、カプセルとAABBの衝突判定が正しく動作することを確認しなさい。
</pre>

>**【2章のまとめ】**
>
>* 
>* 
>* 
