[OpenGL 3D 2022 後期 第03回]

# 

## 習得目標

* 
* 
* 

後期にやりたいことリスト

前半6回は3D STG、後半6回は3D ACTのための機能という方向性かなあ。

3Dモデルを使った2D STGとして完成させるなら、衝突判定は最小限でよい。むしろエフェクト系を充実させるべきか。

建物との衝突を可能にするには、自機を球と考えて「AABBと球の交差判定」が必要。弾については前フレームと現フレームの座標を結び、「線分とAABBの交差判定」を行うことで対応できるはず。

* [x] デプスシャドウ(PCFシャドウ)

* [x] 頂点データの最適化
* [x] stable_partitionのはなし
* [x] ブルームエフェクト

* [ ] ノーマルマッピング(MikkTSpace)
* [ ] インスタンシング(3D)
* [ ] 環境マッピング
* [ ] リニア色空間
* [ ] HDRテクスチャ
* [ ] ディファードレンダリング
* [ ] タイルベースドレンダリングによる大量のライト
* [ ] SSAO(Scalable Anbient Obscurance)

* [ ] PBRレンダリング+フレネル反射

* [ ] 球と球の交差判定、点と直線の距離、点と線分の距離、球と直線の交差判定、球と線分の交差判定

* [ ] 点と平面の距離、球と平面の交差判定、円と直線の交差判定、球とポリゴンの交差判定
* [ ] 直線と平面の交差判定、線分と平面の交差判定、直線とポリゴンの交差判定、線分とポリゴンの交差判定、カプセルと平面の交差判定、カプセルとポリゴンの交差判定
* [ ] 直線と直線の距離、線分と線分の距離、カプセルとカプセルの交差判定
* [ ] AABBと直線の交差判定、AABBと線分の交差判定、AABBと球の交差判定、AABBとカプセルの交差判定、AABBと平面の交差判定、AABBとポリゴンの交差判定
* [ ] AABBをOBBに拡張、OBBとOBBの交差判定
* [ ] FBX読み込み
* [ ] FBXアニメーション
* [ ] ディゾルブエフェクト
* [ ] シェーダによるフェードイン・フェードアウト


## 1. ノーマルマッピング

### 1.1 なぜ法線マッピングを行うのか

<p align="center">
<img src="images/unsplash.com/vitalijs-barilo-azMZaQCUyV8-unsplash.jpg" width="25%" />
<img src="images/unsplash.com/jonathan-borba-PbwP04DkhQA-unsplash.jpg" width="25%" />
<img src="images/unsplash.com/charlie-firth-6v8GsXKJZI8-unsplash.jpg" width="25%" /><br>
[撮影者 布地:vitalijs barilo 道路:jonathan borba 湖面:charlie firth]
</p>

布地の繊維、アスファルトの凹凸(おうとつ)、水面に立つさざなみなど、現実世界には微細な凹凸が数多く存在します。わたしたちは、こうした物体表面の構造の存在に慣れているため、凹凸の感じられない物体は作り物だと感じてしまいます。

このような微細な凹凸をポリゴンで再現しようとすると、膨大な頂点数が必要となります。実際に、映画用のモデルなどでは、微細な凹凸まで制作される場合があります。しかし、ゲームのようにリアルタイム性が求められるアプリケーションでは現実的とはいえません。

そのため、3Dグラフィックス性能が十分ではなかった頃は、これらの凹凸はカラーテクスチャに陰影を描き込むことで再現していました。

しかし、陰影として描き込まれた凹凸は、どこから見ても、またどのような光の当たり方をしても陰影が変化しません。そのため、すぐにまやかしの影であることがバレてしまいます。

この問題を解決するために生まれたのが「法線マッピング」です。法線マッピングの基本的な考え方は次のようなものです。

>凹凸が陰影を生むのは法線方向が異なるからだ。つまり、法線さえ再現できれば実際に凹凸を作る必要はないはずだ。

法線の再現には、カラーのかわりに「法線の変化量(摂動)」を記録したテクスチャを使います。法線を記録したテクスチャのことを「法線テクスチャ」といいます。

### 1.2 法線マッピングの種類

法線テクスチャに記録する法線(の摂動)には、以下の2種類が存在します。

| 名前 | 記録する法線の種類 |
|:-----|:-----|
| オブジェクト空間法線マッピング | モデル座標系(オブジェクト空間)の法線 |
| タンジェント空間法線マッピング | 図形に接する平面を基準とする座標系(タンジェント空間)の法線 |

実装は「オブジェクト空間法線マッピング」のほうが簡単です。そのかわり、「モデルの変形に対応できない」、「テクスチャの再利用が難しい」という欠点があります。

「タンジェント空間法線マッピング」は、実装が複雑になるかわりに「オブジェクト空間法線マッピング」の欠点が解消されています。そのため、多くの法線テクスチャはタンジェント空間用に作られています。

本テキストでは欠点の少ない「タンジェント空間法線マッピング」を実装することにします。

### 1.3 タンジェント空間

>「座標系」は、「空間において、座標を決めるための基本情報」です。

コンピューターグラフィックスにおける「タンジェント空間」は、「頂点座標に接する、頂点法線に垂直な平面を基準とする座標系」として定義されます。

<p align="center">
<img src="images/Tips_07_tangent_vector.jpg" width="33%" /><br>
[緑=タンジェント(T) 赤=バイノーマル(B) 青=頂点法線(N)]
</p>

タンジェント空間のX軸は「タンジェントベクトル」と呼ばれます(「タンジェント空間」の名前の由来)。Y軸は「バイノーマルベクトル」または「バイタンジェントベクトル」と呼ばれます。Z軸は平面の法線で、これは頂点法線と同じです。

タンジェントベクトル`T`とバイノーマルベクトル`B`は、頂点座標に接する平面上であればどんな向きも取り得ます。これは、「タンジェント空間の座標系の定義は無数に存在する」ことを意味します。

とはいえ、法線を定義するには「無数に存在する」と言われても困ります。そこで、タンジェント空間法線マッピングでは、「TとBがテクスチャ座標系のUV軸の向きと一致する座標系」が選択されます。

この座標系では、テクスチャ座標系のU軸がタンジェントベクトルと一致し、V軸がバイノーマルベクトルと一致します。実際の利用法にもとづく説明をすると「法線テクスチャに記録する法線ベクトルの基準となる座標系」が選ばれるわけです。

法線テクスチャと3Dモデルは、この座標系によって関連付けられます。

### 1.3 頂点シェーダにタンジェントベクトル変数を追加する

タンジェント空間法線マッピングでは、頂点ごとにタンジェントベクトルを持たせます。

>今回は説明しませんが、頂点に持たせず、シェーダでタンジェントベクトルを計算するやり方もあります。

それから、法線テクスチャを読み込んでシェーダに割り当てる必要もあります。法線テクスチャはマテリアルとして定義するのが一般的です。

これらを実現するために必要な作業は以下のとおりです。

頂点シェーダ:

>1. タンジェントベクトル用のin変数とout変数を追加。
>2. タンジェントベクトルをワールド座標系に変換。

フラグメントシェーダ:

>1. タンジェントベクトル用のin変数と、法線テクスチャのサンプラを追加。
>2. 法線テクスチャから法線を読み取る。
>3. タンジェント座標系からワールド座標系へ変換する行列を作成。
>4. 法線をポリゴン平面の座標系(タンジェント座標系)からワールド座標系に変換。

C++アプリケーション:

>1. `Material`構造体に法線テクスチャ変数を追加。
>2. MTLファイルから法線テクスチャ名を読み取り、法線テクスチャを読み込んで変数に代入。
>3. 描画前に法線テクスチャをバインド。
>4. `Vertex`構造体に「タンジェントベクトル」変数を追加。
>5. 頂点アトリビュートに「タンジェントベクトル」を追加。
>6. 「タンジェントベクトル」と「バイノーマルベクトルの向き」を計算し、タンジェントベクトル変数に代入。

それでは、頂点シェーダから法線マッピングに対応させていきましょう。`standared_3D.vert`を開き、タンジェントベクトル用のin変数とout変数を追加してください。

なお、`outShadowPosition`と`texDepth`変数については、ロケーション番号とバインディングポイントを変更しているだけです。

```diff
 layout(location=0) in vec3 inPosition;
 layout(location=1) in vec2 inTexcoord;
 layout(location=2) in vec3 inNormal;
+layout(location=3) in vec4 inTangent;
 
 // シェーダからの出力
 layout(location=0) out vec3 outPosition;
 layout(location=1) out vec2 outTexcoord;
 layout(location=2) out vec3 outNormal;
+layout(location=3) out vec4 outTangent;
-layout(location=3) out vec3 outShadowPosition;
+layout(location=4) out vec3 outShadowPosition;
 
 // テクスチャ
-layout(binding=1) uniform sampler2DShadow texDepth;
+layout(binding=2) uniform sampler2DShadow texDepth;

 // プログラムからの入力
 layout(location=0) uniform vec3 translate;
```

`outShdowPosition`のロケーション番号を変更したのは、同じ行列によって変換される変数をまとめるためです。`texDepth`のバインディングポイントの変更も似た理由で、後述する法線テクスチャのバインディングポイントを揃えるためです。

>ロケーション番号に限らず、共通の性質を持つ変数は近くにまとめたり、順番を揃えるようにしましょう。プログラムが読みやすくなります。

### 1.4 タンジェントベクトルをワールド座標系に変換する

次に、タンジェントベクトルをローカル座標系からワールド座標系に変換します。ワールド法線を計算するプログラムの下に、次のプログラムを追加してください。

```diff
   // ワールド法線を計算
   mat3 matNormal = transpose(inverse(mat3(matModel)));
   outNormal = normalize(matNormal * inNormal);
+
+  // ワールドタンジェントを計算
+  outTangent.xyz = normalize(matNormal * inTangent.xyz);
+  outTangent.w = inTangent.w;

   // 影判定用の座標を計算
   float worldShadowRange = 750 * 2; // 深度マップの描画範囲(CreateDepthMap関数を参照)
```

タンジェントベクトルは法線と同じ「向きベクトル」です。そのため、平行移動を含まない`matNormal`行列を使ってワールド座標系に変換します。

これで頂点シェーダの変更は完了です。

### 1.5 フラグメントシェーダにタンジェントベクトル変数を追加する

続いて、フラグメントシェーダを法線マッピングに対応させます。まずタンジェントベクトル用の変数を追加しましょう。`standard_3D.frag`を開き、変数定義を次のように変更してください。

```diff
 layout(location=0) in vec3 inPosition;
 layout(location=1) in vec2 inTexcoord;
 layout(location=2) in vec3 inNormal;
+layout(location=3) in vec4 inTangent;
-layout(location=3) in vec3 inShadowPosition;
+layout(location=4) in vec3 inShadowPosition;

 // テクスチャ
 layout(binding=0) uniform sampler2D texColor;
+layout(binding=1) uniform sampler2D texNormal;
-layout(binding=1) uniform sampler2DShadow texDepth;
+layout(binding=2) uniform sampler2DShadow texDepth;

 // 出力する色データ
 out vec4 outColor;
```

ここでも、`inShadowPosition`と`texDepth`は、ロケーション番号またはバインディングポイントを変えているだけです。

`texDepth`のバインディングポイントを変えた理由は、`texColor`と`texNormal`はマテリアルですが、`texDepth`はマテリアルではないからです。

### 1.6 法線テクスチャから法線を読み取る

法線マッピングでは、法線テクスチャと頂点の法線及びタンジェントを使ってピクセルの法線を計算します。少し長い処理になるので、関数として定義することにします。

関数名は`ComputeWorldNormal`(コンピュート・ワールド・ノーマル)とします。環境光パラメータの定義の下に、次のプログラムを追加してください。

```diff
 // 環境光パラメータ
 layout(location=104) uniform vec3 ambientLight;
+
+/**
+* 法線を計算する
+*/
+vec3 ComputeWorldNormal()
+{
+}
+
+/**
+* エントリーポイント
+*/
 void main()
 {
```

それでは、`texNormal`から法線を読み取るプログラムを追加しましょう。`ComputeWorldNormal`関数に次のプログラムを追加してください。

```diff
 */
 vec3 ComputeWorldNormal()
 {
+  vec3 normal = texture(texNormal, inTexcoord).rgb;
+
+  // 値が小さすぎる場合、法線テクスチャが設定されていないと判断して頂点法線を返す
+  if (dot(normal, normal) <= 0.0001) {
+    return normalize(inNormal);
+  }
+
+  // 8bit値であることを考慮しつつ0～1を-1～+1に変換(128を0とみなす)
+  normal = normal * (255.0 / 127.0) - (128.0 / 127.0);
 }

 /**
```

法線テクスチャの読み込み方法は、通常のテクスチャと変わりません。法線テクスチャを持たない3Dモデルを考慮して、読み込んだ値が小さすぎる場合は「法線テクスチャなし」と判定しています。

この判定が有効なのは、法線テクスチャの仕様上、RGBが全て0になることはありえないためです。もし全て0になるとしたら、それはテクスチャがバインドされていない場合です。

#### 変換式に現れる255/127と128/127の意味

一般に、法線テクスチャには、法線のXYZ値(-1～+1)をRGBカラー(0～1)に変換した値が記録されます。法線テクスチャが明るい青紫色になるのは、この変換の結果、頂点法線と一致する値が(0.5, 0.5, 1.0)になるからです。

法線テクスチャから読み取った値の範囲は0～1となりますが、そのままでは法線ベクトルとして使えません。そこで、値を`-1～+1`に復元する必要があります。

しかし、法線ベクトルは「32ビット浮動小数点数」で表されるのに対して、法線テクスチャに記録できるのは「8ビット符号なし整数」です。精度にこれほど大きな<ruby>隔<rt>へだ</rt></ruby>たりがあると、正確な復元は不可能です。

そのため、性質の異なる2つの復元方法が考えられました。

| 復元方法 | 利点 | 欠点 |
|:-:|:--|:--|
| 法線テクスチャ * 2 - 1 | 誤差が小さい | 0を表現できない |
| (法線テクスチャ * 255 - 128) / 127 | 0を表現できる | 誤差が大きい |

上側の方法では`-1`→`0`, `0`→`127.5`, `+1`→`255`のように割り当てます。この割り当て方では`0`を整数で表すことができません。そのかわり、`-1～0`と`0～+1`の両方を128段階で表すことができ、。

下側の方法では`-1`→`0`, `0`→`128`, `+1`→`255`のように割り当てます。この割り当て方では、`0`を除いて`-1～0`が128段階、`0～+1`が127段階となり、プラス側の表現力が低下します。そのかわり、`0`を正確に表せます。

どちらを使うかはアプリケーション次第ですが、基本的には下側の方法が使われます。0を表現できないと(0, 0, 1)のような垂直ベクトルが表せないためです。この理由から、本テキストでも下側の方法を採用しています。

もちろん、「浮動小数点数テクスチャ」を使えば上記の問題はなくなります。しかし、必要なメモリが2倍～4倍になるため、2022年現在ではほとんど使われていません。

>法線テクスチャの誤差については以下のURLが詳しいです。<br>
>`http://www.aclockworkberry.com/normal-unpacking-quantization-errors/`<br>
>`http://wiki.polycount.com/wiki/Normal_Map_Technical_Details`

### 1.7 法線ベクトルをワールド座標系に変換する

法線テクスチャから読み込んだ法線ベクトルは「タンジェント座標系」にあります。これをワールド座標系に変換するには、タンジェント座標系の各軸をワールド座標系で表現したベクトルを作り、そのベクトルに各成分を乗算します。

タンジェント座標系の軸はX=タンジェント、Y=バイノーマル、Z=ノーマル(これは法線のことです)と呼ばれます。このうちタンジェントとノーマルはin変数で受け取っているので、あとはバイノーマルを計算するだけです。

バイノーマルは、タンジェントとノーマルに直交するように定義されます。直交するベクトルは外積によって計算できるので、頂点データにはノーマルとタンジェントの2つを持たせれば十分です。

ただし、直交ベクトルの向きにはプラス方向とマイナス方向の2つがありえます。しかし、外積は常にプラス方向になります。つまり、ノーマルとタンジェントだけでは直交ベクトルの向きを決めるには不十分なのです。

そこで、CPPアプリケーションでタンジェントベクトルを計算するとき、バイノーマルの正しい方向をタンジェントベクトルの`w`要素に設定しておきます。この処理は後で書きますが、シェーダはこれを前提として作成します。

法線テクスチャから読み取った法線を変換するプログラムの下に、次のプログラムを追加してください。

```diff
   // 8bit値であることを考慮しつつ0～1を-1～+1に変換(128を0とみなす)
   normal = normal * (255.0 / 127.0) - (128.0 / 127.0);
+
+  // 法線テクスチャの値をワールド空間に変換
+  vec3 binormal = inTangent.w * cross(inNormal, inTangent.xyz);
+  return normalize(
+    inTangent.xyz * normal.x +
+    binormal * normal.y +
+    inNormal * normal.z);
 }

 /**
```

これで法線ベクトルを計算する関数は完成です。最後に、作成した関数を`main`関数から呼び出しましょう。`main`関数を次のように変更してください。

```diff
   outColor = texture(texColor, inTexcoord) * material.baseColor;

   float invPi = 1 / acos(-1); // πの逆数

-  // 線形補間によって長さが1ではなくなっているので、正規化して長さを1に復元する
-  vec3 normal = normalize(inNormal);
+  vec3 normal = ComputeWorldNormal();

   // ランベルトの余弦則を使って明るさを計算
   float theta = max(dot(-directionalLight.direction, normal), 0);
```

これで、フラグメントシェーダの変更は完了です。

### 1.8 Material構造体に法線テクスチャ変数を追加する

ここからは、CPPアプリケーション側を法線マッピングに対応させていきます。まずマテリアルに法線テクスチャ変数を追加します。`Mesh.h`を開き、`Material`構造体の定義に次のプログラムを追加してください。

```diff
   float specularPower = 16;                   // 鏡面反射指数
   float normalizeFactor = 24.0f / 25.13274f;  // 正規化係数
   TexturePtr texBaseColor;                    // 基本色テクスチャ
+  TexturePtr texNormal;                       // 法線テクスチャ
 };
 using MaterialPtr = std::shared_ptr<Material>;
```

次に、追加した`texNormal`にテクスチャを読み込みます。`Mesh.cpp`を開き、`LoadMTL`関数にある基本色テクスチャを読み取りを試みるプログラムの下に、次のプログラムを追加してください。

```diff
           Texture::Usage::for3D);
       continue;
     }
+
+    // 法線テクスチャ名の読み取りを試みる
+    textureName[0] = 0;
+    if (sscanf(line.data(), " bump %999[^\n]", &textureName) < 1) {
+      sscanf(line.data(), " map_bump %999[^\n]", &textureName);
+    }
+    if (textureName[0] != 0) {
+      pMaterial->texNormal =
+        Texture::Create(foldername + textureName, GL_LINEAR,
+          Texture::Usage::for3D);
+      continue;
+    }
   }

   return materials;
```

MTLファイルにおける法線テクスチャの構文は`bump`です。しかし、`map_bump`という構文も広く使われているため、両方に対応させることにしました。

読み取りの成功・失敗は`textureName`配列の0番目の要素で判定しています。何らかの名前が読み取れたなら`0`以外になるはずなので、最初に`0`を設定しておくことで判別できるようにしています。

### 1.9 法線テクスチャをGLコンテキストに割り当てる

読み込んだテクスチャを使うには、GLコンテキストに割り当てなくてはなりません。`StaticMesh`用の`Draw`関数の定義を、次のように変更してください。

```diff
         glProgramUniform3f(program, 103,
           material.specularPower, material.normalizeFactor, 0);
       }

+      // GLコンテキストにテクスチャを割り当てる
+      GLuint tex[2] = { 0 };
       if (material.texBaseColor) {
-        const GLuint tex = *material.texBaseColor;
+        tex[0] = *material.texBaseColor;
-        glBindTextures(0, 1, &tex);
-      } else {
-        glBindTextures(0, 1, nullptr);
       }
+      if (material.texNormal) {
+        tex[1] = *material.texNormal;
+      }
+      glBindTextures(0, 2, tex);
     }
     Draw(prim);
```

ここには、テクスチャのバインディングポイントの順序を変更した理由のひとつが現れています。`texColor`と`texNormal`のバインディングポイントを連番にしたことで、1回の`glBindTextures`関数でを設定できるわけです。

### 1.10 深度テクスチャの割り当てを変更する

そうそう、バインディングポイントの番号を変更したので、深度テクスチャの割り当てプログラムも修正しなくてはなりません。`Engine.cpp`を開き、`MainLoop`メンバ関数にある深度テクスチャを割り当てるプログラムを、次のように変更してください。

```diff
   // 影描画用の深度テクスチャを割り当てる
   const GLuint texDepth = *fboShadow->GetDepthTexture();
-  glBindTextures(1, 1, &texDepth);
+  glBindTextures(2, 1, &texDepth);

   // 影座標からテクスチャ座標に変換する行列
   const mat4 matTexture = {
```

これで法線テクスチャの設定は完了です。

### 1.11 Vertex構造体にタンジェントベクトルを追加する

続いて、頂点データにタンジェントベクトルを追加していきます。`Mesh.h`を開き、`Vertex`構造体にタンジェントベクトル変数を追加してください。

```diff
   VecMath::vec3 position;
   VecMath::vec2 texcoord;
   VecMath::vec3 normal;
+  VecMath::vec4 tangent;
 };

 /**
 * マテリアル(材質)
```

次に、頂点アトリビュートにタンジェントベクトルを追加します。`Mesh.cpp`を開き、`PrimitiveBuffer`コンストラクタの定義に次のプログラムを追加してください。

```diff
   setAttribute(0, 3, offsetof(Vertex, position));
   setAttribute(1, 2, offsetof(Vertex, texcoord));
   setAttribute(2, 3, offsetof(Vertex, normal));
+  setAttribute(3, 4, offsetof(Vertex, tangent));

   // バインド解除
   glBindVertexArray(0);
```

これで`tangent`変数が頂点シェーダに送られるようになりました。

### 1.12 タンジェントベクトルの求めかた

最後に、タンジェントベクトルを計算します。計算手順は以下のようになります。

>1. ポリゴン単位でタンジェントベクトルを計算して加算。
>2. 全ての計算が完了したら、正規化して単位ベクトルに変換。

それではプログラムを書いていきましょう。加算していくので、初期値を0にして置く必要があります。`LoadOBJ`メンバ関数の「新しい頂点データを作成」するプログラムに、次のプログラムを追加してください。

```diff
     } else {
       v.normal = normals[e.vn - 1];
     }
+    v.tangent = vec4(0); // 初期値を0にする
     vertices.push_back(v);
   }
```

次にタンジェントベクトルを計算します。ポリゴンの頂点座標P0, P1, P2と、テクスチャ座標(u0,v0), (u1,v1), (u2,v2)があり、次のようにテクスチャが貼られているとします。

<p align="center">
<img src="images/14_tangent_space_edge.png" width="33%" />
</p>

このとき、(u0,v0)と(u1,v1)を結ぶ線分e1は、ベクトルTとBを用いて次のように表わすことができます。

>`e1 = (u1 - u0)T + (v1 - v0)B`

同様に、線分e2は次のように表せます。

>`e2 = (u2 - u0)T + (v2 - v0)B`

上記の2つの式を連立方程式として考えると、これは次のように行列で書くことができます。

>```txt
>| e1.x e1.y e1.z |   | (u1-u0) (v1-v0) |   | T.x T.y T.z |
>| e2.x e2.y e2.z | = | (u2-u0) (v2-v0) | * | B.x B.y B.z |
>```

これを簡略化して`E = A * B`とすると、求めたいタンジェントベクトルは`B`です。また、上の図から`E`と`A`は計算できることが分かっています。

この式の両辺に`A`の逆行列`A(-1)`を掛けると次のようになります。

>`A(-1) * E = A(-1) * A * B`

`A(-1) * A`は単位行列なので消去して、

>`B = A(-1) * E`

が得られます。ようするに「`A`の逆行列を`E`に掛ければタンジェントベクトルが求められる」ということです。

2x2行列の逆行列を求めるには次の公式を使います。

>```txt
>     | a b |
>A = | c d |
>
>                         | d -b |
>A(-1) = 1 / (ad - bc) * |-c  a |
>```

また、今回求めるのはタンジェントだけなので、`T`に関する計算だけを行えば十分です。これは`1 / (ad - bc)`を`S`とすると、

>`T = S * ((v2 - v0) * e1 - (v1 -v0) * e2)`

これで、タンジェントベクトルを求める方法が分かりました。

### 1.13 辺ベクトルを求める

それでは、計算式をプログラムしていきましょう。とりあえず辺ベクトルe1, e2と、uvの差分uv1, uv2を求めます。OpenGLで使えるデータに変換するループの下に、次のプログラムを追加してください。

```diff
     v.tangent = vec4(0); // 初期値を0にする
     vertices.push_back(v);
   }
+
+  // タンジェントベクトルを計算
+  for (size_t i = 0; i < indices.size(); ++i) {
+    // 頂点座標とテクスチャ座標の辺ベクトルを計算
+    const size_t offset = (i / 3) * 3;
+    const int i0 = indices[(i + 0) % 3 + offset];
+    const int i1 = indices[(i + 1) % 3 + offset];
+    const int i2 = indices[(i + 2) % 3 + offset];
+    Vertex& v0 = vertices[i0];
+    Vertex& v1 = vertices[i1];
+    Vertex& v2 = vertices[i2];
+    vec3 e1 = v1.position - v0.position; // 座標ベクトル
+    vec3 e2 = v2.position - v0.position; // 座標ベクトル
+    vec2 uv1 = v1.texcoord - v0.texcoord; // テクスチャ座標ベクトル
+    vec2 uv2 = v2.texcoord - v0.texcoord; // テクスチャ座標ベクトル
+  }

  // 変換したデータをプリミティブバッファに追加
  const GLint baseVertex = 
```

ループ変数`i`は、タンジェントベクトルを求める頂点インデックスのオフセットです。変数`i0`, `i1`, `i2`はポリゴンを構成する頂点インデックスのオフセットです。

`i = 0`のとき`i0 = 0, i1 = 1, i2 = 2`、`i= 1`のとき`i0 = 1, i1 = 2, i2 = 0`、`i = 2`のとき`i0 = 2,i1 = 0, i2 = 1`となります。

0, 1, 2は最初のポリゴンの頂点インデックスです。同様に、変数`i`が`3～5`のときは`3,4,5`, `4,5,3`, `5,3,4`となり、`i`が`6～8`のときは`6,7,8', '7,8,6`, `8,6,7`となります。

<p align="center">
<img src="images/14_tangent_calculation_0.png" width="45%" /><br>
[i=0, i=1, i=2のときの辺ベクトルe1, e2の向き]
</p>

### 1.14 辺ベクトルの有効性を判定する

次に、テクスチャ座標ベクトルuv1とuv2の外積を計算します。ベクトルを計算するプログラムの下に、次のプログラムを追加してください。

```diff
     vec3 e2 = v2.position - v0.position; // 座標ベクトル
     vec2 uv1 = v1.texcoord - v0.texcoord; // テクスチャ座標ベクトル
     vec2 uv2 = v2.texcoord - v0.texcoord; // テクスチャ座標ベクトル
+
+    // テクスチャの面積がほぼ0の場合は無視
+    float uvArea = uv1.x * uv2.y - uv1.y * uv2.x; // uvベクトルによる平行四辺形の面積
+    if (abs(uvArea) < 0x1p-20) { // 十六進浮動小数点数リテラル(C++17)
+      continue;
+    }
   }

  // 変換したデータをプリミティブバッファに追加
```

外積の結果はUV平面に垂直なベクトルです。このベクトルの長さは、2つの辺ベクトルによって作られる平行四辺形の面積をあらわします。

<p align="center">
<img src="images/14_tangent_calculation_2.png" width="33%" />
</p>

uv1とuv2の向きが等しい、またはいずれかのベクトルの長さが0の場合、平行四辺形の面積は0になります。どちらの場合もタンジェントベクトルを計算できません。そこで、面積が「ほぼ0」の場合は`continue`して以降の計算をスキップします。

`0x1p-20`はC++17で追加された「16進数の指数表記」」です。`p`の前が「仮数部(かすうぶ)」、後が「指数部(しすうぶ)」で、以下の式で10進数に戻すことができます。

>`仮数部 * 2^指数部`

`0x1p-20`の場合、仮数部は`0x1`、指数部は`-20`です。これを上の式に当てはめると、`0x1 * 2^-20 = 0.00000095367431640625`となります。

>**【浮動小数点数の計算誤差を常に考慮しよう】**<br>
>「ぴったり0」ではなく「ほぼ0」で判定するのは、浮動小数点数の計算誤差を考慮するためです。「0.1fを10回足しても1.0fにならない」など、浮動小数点数の計算に誤差はつきものです。そのため、等号`==`による比較はうまくいきません。代わりに不等号を使って、「ある一定の範囲の値」と比較するようにしましょう。

### 1.15 バイノーマルベクトルの向きを決める

次に、バイノーマルベクトルの向きを決めます。テクスチャの面積がほぼ0の場合を判定するプログラムの下に、次のプログラムを追加してください。

```diff
     if (abs(uvArea) < 0x1p-20) { // 十六進浮動小数点数リテラル(C++17)
       continue;
     }
+
+    // テクスチャが裏向きに貼られている(面積が負の)場合、バイノーマルベクトルの向きを逆にする
+    if (uvArea >= 0) {
+      v0.tangent.w = 1; // 表向き
+    } else {
+      v0.tangent.w = -1;// 裏向き
+    }
   }

  // 変換したデータをプリミティブバッファに追加
```

次の図のように、外積の結果は元になったベクトルの向きによって符号が異なります。

<p align="center">
<img src="images/14_tangent_calculation_1.png" width="45%" /><br>
[左=uv1がプラス向き 右=uv1がマイナス向き]
</p>

右図のように、テクスチャ座標が逆を向いている場合、タンジェント空間も反転していることを意味します。つまり、バイノーマルベクトルが逆向きになります。

### 1.16 タンジェントベクトルを求める

それではタンジェントベクトルを求めましょう。まず辺ベクトルをタンジェント平面と平行になるように修正します。バイノーマルベクトルの向きを決めるプログラムの下に、次のプログラムを追加してください。

```diff
     } else {
       v0.tangent.w = -1;
     }
+
+    // タンジェント平面と平行なベクトルにするため、法線方向の成分を除去
+    e1 -= v0.normal * dot(e1, v0.normal);
+    e2 -= v0.normal * dot(e2, v0.normal);
   }

  // 変換したデータをプリミティブバッファに追加
```

辺ベクトルをタンジェント平面と平行にするには、辺ベクトルから法線方向の成分を除去します。「法線方向の成分」は、辺ベクトルを法線方向に射影した長さ(これは内積によって求められます)と法線を掛けたものです。

次にタンジェントベクトルを計算します。すでにe1, e2はタンジェント平面上にあるので、1.12節で求めた以下の式のとおりに計算するだけです。タンジェント平面上の辺ベクトルを求めるプログラムの下に、次のプログラムを追加してください。

>`T = S * ((v2 - v0) * e1 - (v1 - v0) * e2)`

プログラム中では`v2 - v0`は`uv2.y`、`v1 - v0`は`uv1.y`に相当することに注意してください。タンジェント平面と平行な辺ベクトルを求めるプログラムの下に、次のプログラムを追加してください。

```diff
     // タンジェント平面上のベクトルにするため、法線方向の成分を除去
     e1 -= v0.normal * dot(e1, v0.normal);
     e2 -= v0.normal * dot(e2, v0.normal);
+
+    // タンジェントベクトルを計算
+    vec3 tangent = normalize((uv2.y * e1 - uv1.y * e2) * v0.tangent.w);
```

上の式で求められるタンジェントベクトルの方向は、バイノーマルと同様にテクスチャ座標の向きによって異なります。バイノーマルとタンジェントの両方を逆向きにすると、それは逆向きではなくなってしまいます。

そのため、タンジェントベクトルの方向はテクスチャ座標の向きに関わらず同じでなくてはなりません。そこで、最後に`w`を掛けることで常に同じ方向を向けさせています。

### 1.17 タンジェントベクトルを加算する

続いて、計算したタンジェントベクトルを頂点のタンジェントデータに加算します。タンジェントベクトルを計算するプログラムの下に、次のプログラムを追加してください。

```diff
     // タンジェントベクトルを計算
     vec3 tangent = normalize((uv2.y * e1 - uv1.y * e2) * v0.tangent.w);
+
+    // 辺ベクトルのなす角を重要度としてタンジェントを合成
+    float angle = acos(dot(e1, e2) / (length(e1) * length(e2)));
+    v0.tangent += vec4(tangent * angle, 0);
   }

  // 変換したデータをプリミティブバッファに追加
```

このプログラムでは、辺ベクトルe1とe2のなす角度によってタンジェントベクトルの重要度を変えています。次の図が示すように、「角度が大きいポリゴンほど、その頂点に影響する面積が広い」と考えられるからです。

<p align="center">
<img src="images/14_tangent_calculation_3.png" width="15%" />
</p>

### 1.17 タンジェントベクトルを正規化する

ここまでで、全てのポリゴンのタンジェントベクトルを計算し終えました。各頂点の`tangent`変数には、その頂点に影響する全てのタンジェントベクトルが加算されています。

複数のベクトルを加算して作られたベクトルは、正規化することで平均値を出すことができます。

```diff
     float angle = acos(dot(e1, e2) / (length(e1) * length(e2)));
     v0.tangent += vec4(tangent * angle, 0);
   }
+
+  // タンジェントベクトルを正規化
+  for (auto& e : vertices) {
+    vec3 t = normalize(vec3(e.tangent.x, e.tangent.y, e.tangent.z));
+    e.tangent = vec4(t.x, t.y, t.z, e.tangent.w);
+  }

  // 変換したデータをプリミティブバッファに追加
  const GLint baseVertex = 
```

これで、頂点の「タンジェントベクトル」と「バイノーマルの向き」を求めることができました。

>**【1章のまとめ】**
>
>* 
>* 
>* 

<div style="page-break-after: always"></div>

## 2. 法線テクスチャを作成する

### 2.1 法線テクスチャを作成する

ここまでで、法線マッピング自体は実行できるようになっています。とはいえ、肝心の法線テクスチャがなければ意味がありません。そこで、地面の草に法線テクスチャを追加しようと思います。

法線テクスチャを作成するには、法線テクスチャ作成ツールが必要です。

Materialize(マテリアライズ)というツールを使うことにします。WebブラウザのURL入力欄に以下のURLを入力して、Materializeの公式サイトを開いてください。

>`www.boundingboxsoftware.com/materialize/`

<p align="center">
<img src="images/14_materialize_homepage.png" width="45%" /><br>
[Materialize公式サイト(2022.09現在)]
</p>

ページを一番下までスクロールさせると、次のようなダウンロードボタンがあると思います。このボタンをクリックしてZIPファイルをダウンロードしてください。

<p align="center">
<img src="images/14_materialize_download.png" width="33%" />
</p>

ダウンロードしたZIPファイルを「展開」し、適当なフォルダに配置してください。Materializeのインストールはこれだけです。展開したフォルダ内にある`Materialize.exe`をダブルクリックして、Materializeを起動してください。

<p align="center">
<img src="images/14_materialize_run.png" width="25%" />
</p>

すると、次のようなウィンドウが開きます。

<p align="center">
<img src="images/14_materialize_app_0.jpg" width="80%" />
</p>

まず`Diffuse Map`パネルにある`O`(オー)`ボタンをクリックしてください。するとファイル選択ウィンドウが開きます。

<p align="center">
<img src="images/14_materialize_app_1.jpg" width="50%" />
</p>

プロジェクトの`Res`フォルダから地面のテクスチャを選択し、右下の`Select`ボタンをクリックしてください。

<p align="center">
<img src="images/14_materialize_app_2.jpg" width="50%" />
</p>

すると、次のように地面テクスチャが表示された状態になります。

<p align="center">
<img src="images/14_materialize_app_3.jpg" width="50%" />
</p>

そうしたら、今度は`Height map`(ハイトマップ)パネルにある`Create`(クリエイト)ボタンをクリックしてください。すると、左側に「ハイトマップ作成パネル」が開き、中央のモデルが地面テクスチャと作成されるハイトマップに2分割表示されます。

<p align="center">
<img src="images/14_materialize_app_4.jpg" width="50%" />
</p>

初期設定では高さの変化がほとんどないので、パラメータを調整します。まず「ハイトマップ作成パネル」にある`Details`(ディティールズ)ボタンをクリックしてください(①)。`Details`はテクスチャが詳細な凹凸を含む場合に使う設定です。

次に、下の方にある`Final Contrast`(ファイナル・コントラスト)の値を`5`にしてください。これで陰影がくっきりするはずです(②)。

2つのパラメータを設定したら、一番下にある`Set as Height Map`(セット・アズ・ハイトマップ)ボタンをクリックすると、高さテクスチャが作成されます(③)。

>**【ハイトマップ(高さマップ)って何？】**<br>
>ハイトマップは「テクセル座標の高さ」を表すテクスチャです。一般的には白黒画像で、高い部分ほど白く、低い部分ほど黒くなります。

高さテクスチャを作成したら、いよいよ法線テクスチャを作成します。`Normal Map`(ノーマルマップ)パネルにある`Create`(クリエイト)ボタンをクリックしてください。

<p align="center">
<img src="images/14_materialize_app_5.jpg" width="33%" />
</p>

すると、左側に「法線マップ作成パネル」が表示され、中央のモデルには次のような青紫の画像が表示されます。今回はとくに修正する必要はないので、一番下にある`Set as Normal Map`(セット・アズ・ノーマルマップ)ボタンをクリックしてください。

<p align="center">
<img src="images/14_materialize_app_6.jpg" width="50%" />
</p>

法線テクスチャがセットされたら`Preview`(プレビュー)ボタンをクリックして「法線マップ作成パネル」を閉じてください。

<p align="center">
<img src="images/14_materialize_app_7.jpg" width="33%" />
</p>

さて、MaterializeはデフォルトではDirectX用の法線テクスチャを作成します。Y軸の向きが逆なので、そのままではOpenGLでは使えません。そこで、`Saving Options`(セービング・オプションズ)パネルにある`Flip Normal Y`ボタンをクリックしてください。

<p align="center">
<img src="images/14_materialize_app_8.jpg" width="33%" />
</p>

すると、Y軸に相当する緑成分の値が反転します。これでOpenGL用の法線テクスチャをになりました。

それから、保存するファイル形式をTGAにするため、`Fiel Format`の下の一覧から`TGA`をクリックしてチェックマークを付けておいてください。

それでは、作成した法線テクスチャを保存しましょう。特定のテクスチャを保存するには、各パネルにある`S`ボタンをクリックします。今回は法線テクスチャなので、`Normal Map`パネルにある`S`ボタンをクリックしてください。

<p align="center">
<img src="images/14_materialize_app_9.jpg" width="33%" />
</p>

保存ダイアログが表示されるので、

>`地面テクスチャ名_normal.tga`

のように、元のテクスチャ名に`_normal`を付けて保存してください。これで法線テクスチャが作成されました。

### 2.2 MTLファイルに法線テクスチャを追加する

作成した法線テクスチャを地面モデルに追加します。`Res`フォルダにある`Ground.mtl`ファイルを開き、次のテキストを追加してください。

```diff
 newmtl grassHR2 02
 Kd 1 1 1
 map_Kd grassHR2 02.tga
+bump grassHR2 02_normal.tga
 Ns 20
 illum 2
```

MTLファイルを修正したら、プログラムを実行してください。地面に凹凸があるように見えていたら成功です。

<p align="center">
<img src="images/14_result_0.jpg" width="45%" />
</p>

このように、法線テクスチャを利用すると、ポリゴンでは難しい複雑な凹凸を表現することができます。

>**【2章のまとめ】**
>
>* 
>* 
>* 

<div style="page-break-after: always"></div>

## 3. MikkTSpace(ミック・ティー・スペース)

### 3.1 作成時と利用時で同じ座標系を使う

「法線テクスチャを作成するとき」と「法線テクスチャから法線を読み出すとき」の両方で、同じ座標系を使うことが重要です。

タンジェント空間の座標系はポリゴンごとに定義されます。なぜなら、ポリゴンの法線と、ポリゴンに貼り付けられるテクスチャの向きは、ポリゴンごとに異なっているからです。

このことは、頂点が複数のポリゴンで共有されている場合に問題となります。一般に、「ひとつの頂点に設定できるタンジェント空間はひとつだけ」だからです。

そのため、法線テクスチャ作成ツールは「頂点が関わる全てのタンジェント空間を統合」する処理を行います。そして、統合されたタンジェント空間を使って法線テクスチャを作成します。

問題は「統合手順が公開されていないツールがある」ことです。手順が公開されていない場合、ツールと同じタンジェント空間を計算することはほとんど不可能です。法線を正しく復元できず、不自然な陰影が生まれることになります。

法線テクスチャと3Dモデルのタンジェント空間を一致させるため、法線テクスチャと3Dモデルは同じモデリングツールで作成するのが習慣となっていました。

しかし近年は、3Dモデルに求められる水準が上がり、ひとつのツールですべての作業を行うことが困難になってきました。

2022年現在では、`MikkTSpace`(ミック・ティー・スペース)という方法が、タンジェント空間を計算する標準的な方法になっています。

`MikkTSpace`はMorten S. Mikkelsen氏が2008年の論文で発表したタンジェント空間の計算方法です。計算結果の品質が高いことから、現代では多くの3Dツールやゲームエンジンで採用されています。

>論文は以下のURLからダウンロードできるようです(コペンハーゲン大学のサイト)
>`http://image.diku.dk/projects/media/morten.mikkelsen.08.pdf`

通常は、`https://github.com/mmikk/MikkTSpace`で公開されているソースファイルを組み込んで利用します。MikkTSpaceは、元データが同じであれば、入力データの順序が異なっていても同じタンジェント空間を出力するように設計されています。

そのため、上記サイトのソースコードを利用している環境間では、タンジェント空間の不一致を防ぐことができます。

それでは、ソースファイルをダウンロードしてプロジェクトに組み込みましょう。ブラウザで`https://github.com/mmikk/MikkTSpace`を開いてください。すると次のようなページが表示されます。

<p align="center">
<img src="images/14_mikktspace_0.png" width="50%" />
</p>

`Code`(コード)と書かれた緑色のボタンをクリックすると、サブメニューが表示されます。一番下の`Download ZIP`(ダウンロード・ジップ)をクリックして、適当なフォルダにZIPファイルをダウンロードしてください。

次に、プロジェクトの`Src`フォルダに`MikkTSpace`という名前のフォルダを作成してください。

<p align="center">
<img src="images/14_mikktspace_1.png" width="45%" />
</p>

ダウンロードしたZIPファイルを展開すると`mikktspace.h`と`mikktspace.c`というファイルが見つかります。この2つのファイルを、先ほど作成した`MikkTSpace`フォルダにコピーしてください。





>`https://stackoverflow.com/questions/5255806`

MikkTSpaceでは「タンジェントとバイノーマルのなす角」に注目します。そして「角度が狭いほど重要度が低い」と判定します。





>6. 「タンジェントベクトル」と「バイノーマルベクトルの向き」を計算し、タンジェントベクトル変数に代入。















>**【1章のまとめ】**
>
>* 
>* 
>* 

<div style="page-break-after: always"></div>

## 2. 

### 2.1 

>**【2章のまとめ】**
>
>* 
>* 
>* 

<div style="page-break-after: always"></div>

